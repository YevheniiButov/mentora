{% extends "games/base_game.html" %}

{% block title %}Super Mentora - 8-Bit Game{% endblock %}

{% block game_title %}{% endblock %}
{% block game_subtitle %}{% endblock %}

{% block content %}
<style>
    /* 8-BIT RETRO STYLING */
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    
    /* Hide header completely */
    .game-header {
        display: none !important;
    }
    
    * {
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
    }
    
    .game-container {
        max-width: 900px !important;
        position: relative;
    }
    
    /* Back button positioned at top-left */
    .pixel-back-btn {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.9);
        color: #fcfc00;
        border: 4px solid #fff;
        padding: 10px 18px;
        font-family: 'Press Start 2P', cursive;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
        z-index: 10000;
        text-decoration: none;
        display: inline-block;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    }
    
    .pixel-back-btn:hover {
        background: #fcfc00;
        color: #000;
        transform: scale(1.1) translateX(-5px);
        box-shadow: 0 0 20px #fcfc00;
    }
    
    @media (max-width: 768px) {
        .pixel-back-btn {
            top: 10px;
            left: 10px;
            padding: 8px 14px;
            font-size: 9px;
        }
    }
    
    #gameCanvas {
        display: block;
        margin: 20px auto;
        background: #5c94fc;
        border: 8px solid #222;
        box-shadow: 
            0 0 0 4px #444,
            0 0 20px rgba(0,0,0,0.8),
            inset 0 0 100px rgba(0,0,0,0.3);
    }
    
    .hud {
        font-family: 'Press Start 2P', cursive;
        font-size: 12px;
        color: #fff;
        text-shadow: 2px 2px 0 #000;
        display: flex;
        justify-content: space-between;
        margin-bottom: 15px;
        padding: 10px;
        background: rgba(0,0,0,0.8);
        border-radius: 8px;
    }
    
    .start-screen, .game-over-screen, .victory-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        padding: 30px;
        border: 4px solid #fff;
        text-align: center;
        color: #fff;
        font-family: 'Press Start 2P', cursive;
        font-size: 14px;
        z-index: 100;
        max-width: 500px;
    }
    
    .start-screen h1 {
        font-size: 24px;
        margin: 0 0 20px 0;
        color: #fcfc00;
        text-shadow: 3px 3px 0 #fc0000;
    }
    
    .pixel-btn {
        background: #fcfc00;
        color: #000;
        border: 4px solid #fff;
        padding: 10px 20px;
        font-family: 'Press Start 2P', cursive;
        font-size: 12px;
        cursor: pointer;
        margin: 10px;
        transition: all 0.1s;
    }
    
    .pixel-btn:hover {
        background: #fc0000;
        color: #fff;
        transform: scale(1.05);
    }
    
    .instructions {
        margin: 20px 0;
        font-size: 10px;
        line-height: 2;
        color: #aaa;
    }
</style>

<!-- Back Button -->
<a href="/learning-map" class="pixel-back-btn">
    ‚Üê BACK
</a>

<div class="hud">
    <div>‚ù§Ô∏è <span id="livesDisplay">3</span></div>
    <div>‚≠ê <span id="scoreDisplay">0</span></div>
    <div>üèÜ LV <span id="levelDisplay">1</span></div>
    <div id="dashDisplay">‚ö° <span id="dashStatus">READY</span></div>
    <div id="weaponDisplay" style="display: none;">üî´ <span id="weaponType">NORMAL</span></div>
</div>

<div style="position: relative;">
    <div class="start-screen" id="startScreen">
        <h1>‚≠ê SUPER MENTORA ‚≠ê</h1>
        <p style="color: #00fc00; margin: 20px 0;">RETRO 8-BIT ACTION!</p>
        <p style="color: #fc8000; font-size: 10px; margin: 10px 0;">Featuring RAMBO in Jungle Mode! üí™</p>
        <div class="instructions">
            ‚¨ÖÔ∏è ‚û°Ô∏è MOVE<br>
            ‚¨ÜÔ∏è / SPACE JUMP<br>
            ‚¨ÜÔ∏è x2 DOUBLE JUMP!<br>
            <span style="color: #00fcfc;">Z DASH ATTACK! ‚ö°</span><br>
            <span style="color: #fcfc00;">COMBO = MORE POINTS!</span><br>
            ‚¨áÔ∏è ENTER PIPES<br>
            X SHOOT (Contra mode)<br>
            C CHANGE WEAPON<br>
            ü¶† STOMP ENEMIES<br>
            üíé HIT BLOCKS<br>
            üü¢ GREEN = COINS<br>
            ‚ö´ BLACK = JUNGLE WAR!<br>
            ‚≠ê STARS = POWER<br>
            üö© REACH THE FLAG<br>
        </div>
        <button class="pixel-btn" onclick="startGame()">START GAME</button>
        <button class="pixel-btn" onclick="window.location.href='/learning-map'" style="background: #555; border-color: #777;">BACK TO MENU</button>
        <p style="font-size: 8px; color: #555; margin-top: 20px;">¬© 2025 MENTORA</p>
    </div>
    
    <div class="game-over-screen" id="gameOverScreen" style="display: none;">
        <h2 style="color: #fc0000; font-size: 20px;">GAME OVER</h2>
        <p style="margin: 20px 0;">SCORE: <span id="finalScore">0</span></p>
        <button class="pixel-btn" onclick="restartGame()">TRY AGAIN</button>
        <button class="pixel-btn" onclick="window.location.href='/learning-map'" style="background: #555; border-color: #777;">BACK TO MENU</button>
    </div>
    
    <div class="victory-screen" id="victoryScreen" style="display: none;">
        <h2 style="color: #00fc00; font-size: 20px;">YOU WIN!</h2>
        <p style="margin: 20px 0;">SCORE: <span id="victoryScore">0</span></p>
        <button class="pixel-btn" onclick="nextLevel()">NEXT LEVEL</button>
        <button class="pixel-btn" onclick="backToMenu()">MENU</button>
    </div>
    
    <!-- Cat sprite for all game modes -->
    <img id="catSprite" src="https://opengameart.org/sites/default/files/cat_0.png" style="display: none;">
    
    <!-- Professional Game Sprites from FreeTileset -->
    <img id="platformSprites" src="/static/images/sprites/1.png" style="display: none;">
    <img id="enemySprites" src="/static/images/sprites/Mushroom_1.png" style="display: none;">
    <img id="backgroundSprites" src="/static/images/sprites/BG.png" style="display: none;">
    <img id="decorationSprites" src="/static/images/sprites/Tree_1.png" style="display: none;">
    
    <!-- Additional sprite sheets -->
    <img id="tileSprites" src="/static/images/sprites/2.png" style="display: none;">
    <img id="objectSprites" src="/static/images/sprites/Crate.png" style="display: none;">
    
    <!-- Decorative sprites -->
    <img id="treeSprites" src="/static/images/sprites/Tree_1.png" style="display: none;">
    <img id="bushSprites" src="/static/images/sprites/Bush (1).png" style="display: none;">
    <img id="stoneSprites" src="/static/images/sprites/Stone.png" style="display: none;">
    <img id="mushroomSprites" src="/static/images/sprites/Mushroom_1.png" style="display: none;">
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <!-- Cheat Code Button -->
    <button id="cheatButton" onclick="showCheatInput()" style="position: fixed; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.9); color: #fcfc00; border: 4px solid #fff; padding: 8px 12px; font-family: 'Press Start 2P', cursive; font-size: 10px; cursor: pointer; z-index: 10000; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);">CHEAT</button>
    
    <!-- Sound Toggle Button -->
    <button id="soundToggle" onclick="toggleSound()" style="position: fixed; top: 20px; right: 100px; width: 50px; height: 50px; background: rgba(0, 0, 0, 0.9); color: #fcfc00; border: 4px solid #fff; border-radius: 50%; cursor: pointer; font-size: 20px; z-index: 10000; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);">üîä</button>
    
    <!-- Cheat Code Input -->
    <div id="cheatInput" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9); color: #fcfc00; padding: 20px; border: 4px solid #fff; font-family: 'Press Start 2P', cursive; font-size: 12px; z-index: 10001; display: none;">
        <div style="margin-bottom: 10px;">ENTER CHEAT CODE:</div>
        <input type="text" id="cheatCodeInput" style="background: #000; color: #fcfc00; border: 2px solid #fff; padding: 8px; font-family: 'Press Start 2P', cursive; font-size: 10px; width: 200px;" placeholder="Type cheat code...">
        <br><br>
        <button onclick="executeCheat()" style="background: #fcfc00; color: #000; border: 2px solid #fff; padding: 8px 16px; font-family: 'Press Start 2P', cursive; font-size: 10px; cursor: pointer; margin-right: 10px;">EXECUTE</button>
        <button onclick="closeCheatInput()" style="background: #fc0000; color: #fff; border: 2px solid #fff; padding: 8px 16px; font-family: 'Press Start 2P', cursive; font-size: 10px; cursor: pointer;">CLOSE</button>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// üê± CAT SPRITE FOR ALL MODES
const spriteImg = document.getElementById('catSprite');

// üé® PROFESSIONAL GAME SPRITES
const platformSprites = document.getElementById('platformSprites');
const enemySprites = document.getElementById('enemySprites');
const backgroundSprites = document.getElementById('backgroundSprites');
const decorationSprites = document.getElementById('decorationSprites');
const tileSprites = document.getElementById('tileSprites');
const objectSprites = document.getElementById('objectSprites');

// üå≥ DECORATIVE SPRITES
const treeSprites = document.getElementById('treeSprites');
const bushSprites = document.getElementById('bushSprites');
const stoneSprites = document.getElementById('stoneSprites');
const mushroomSprites = document.getElementById('mushroomSprites');

// üå≥ PRELOADED DECORATIVE SPRITES
const preloadedSprites = {
    trees: [],
    bushes: [],
    stones: [],
    mushrooms: []
};

// üîä SOUND SETTINGS
let soundEnabled = true;

// Preload all decorative sprites
function preloadDecorativeSprites() {
    // Preload tree sprites
    ['Tree_1.png', 'Tree_2.png', 'Tree_3.png'].forEach(treeFile => {
        const img = new Image();
        img.src = `/static/images/sprites/${treeFile}`;
        preloadedSprites.trees.push(img);
    });
    
    // Preload bush sprites
    ['Bush (1).png', 'Bush (2).png', 'Bush (3).png', 'Bush (4).png'].forEach(bushFile => {
        const img = new Image();
        img.src = `/static/images/sprites/${bushFile}`;
        preloadedSprites.bushes.push(img);
    });
    
    // Preload stone sprites
    const stoneImg = new Image();
    stoneImg.src = '/static/images/sprites/Stone.png';
    preloadedSprites.stones.push(stoneImg);
    
    // Preload mushroom sprites
    ['Mushroom_1.png', 'Mushroom_2.png'].forEach(mushroomFile => {
        const img = new Image();
        img.src = `/static/images/sprites/${mushroomFile}`;
        preloadedSprites.mushrooms.push(img);
    });
    
}

// Start preloading
preloadDecorativeSprites();

// üîç SPRITE LOADING COMPLETE

// üé® PROFESSIONAL SPRITE RENDERING SYSTEM
function renderSprite(spriteImg, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight, fallbackColor = '#8b4513') {
    if (!spriteImg || !spriteImg.complete || spriteImg.naturalWidth === 0) {
        // Enhanced fallback with better graphics
        ctx.fillStyle = fallbackColor;
        ctx.fillRect(destX, destY, destWidth, destHeight);
        
        // Add some texture to make it look better
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(destX + 2, destY + 2, destWidth - 4, destHeight - 4);
        
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(destX, destY, destWidth, 2);
        
        // Debug info removed - sprites should load properly now
        return;
    }
    
    try {
        ctx.drawImage(
            spriteImg,
            sourceX, sourceY, sourceWidth, sourceHeight,
            destX, destY, destWidth, destHeight
        );
    } catch (e) {
        // If sprite loading fails, use fallback
        ctx.fillStyle = fallbackColor;
        ctx.fillRect(destX, destY, destWidth, destHeight);
    }
}

// üèóÔ∏è PROFESSIONAL PLATFORM RENDERING
function renderProfessionalPlatform(platform, biome = 'forest') {
    const spriteWidth = 128; // Real sprite size
    const spriteHeight = 128;
    
    // Different biomes use different tile sprites
    const biomeTiles = {
        forest: { base: 1, grass: 2, edge: 3 },
        autumn: { base: 4, grass: 5, edge: 6 },
        winter: { base: 7, grass: 8, edge: 9 },
        desert: { base: 10, grass: 11, edge: 12 },
        industrial: { base: 13, grass: 14, edge: 15 }
    };
    
    const tiles = biomeTiles[biome] || biomeTiles.forest;
    
    // Try to use real sprites first
    if (platformSprites && platformSprites.complete && platformSprites.naturalWidth > 0) {
        // Render platform base using real sprites - use different parts of sprite
        const tileSize = 32;
        const spriteTileSize = 32; // Use 32x32 portion of the 128x128 sprite
        
        for (let x = 0; x < platform.width; x += tileSize) {
            const tileWidth = Math.min(tileSize, platform.width - x);
            // Use different parts of the sprite for variety
            const spriteX = (Math.floor(x / 32) % 4) * 32; // Cycle through 4 different tiles
            const spriteY = 0; // Use top row of tiles
            
            renderSprite(
                platformSprites,
                spriteX, spriteY, spriteTileSize, spriteTileSize,
                platform.x + x, platform.y, tileWidth, platform.height,
                '#5a3a1a'
            );
        }
        
        // Render grass top
        for (let x = 0; x < platform.width; x += tileSize) {
            const tileWidth = Math.min(tileSize, platform.width - x);
            const spriteX = (Math.floor(x / 32) % 4) * 32; // Cycle through 4 different tiles
            const spriteY = 32; // Use second row for grass
            
            renderSprite(
                platformSprites,
                spriteX, spriteY, spriteTileSize, 16,
                platform.x + x, platform.y - 8, tileWidth, 8,
                '#2a6a2a'
            );
        }
    } else {
        // Fallback to enhanced graphics
        const biomeColors = {
            forest: { base: '#5a3a1a', grass: '#2a6a2a', edge: '#4a2a0a' },
            autumn: { base: '#8b4513', grass: '#cd853f', edge: '#a0522d' },
            winter: { base: '#708090', grass: '#ffffff', edge: '#2f4f4f' },
            desert: { base: '#daa520', grass: '#f4a460', edge: '#cd853f' },
            industrial: { base: '#696969', grass: '#32cd32', edge: '#2f4f4f' }
        };
        
        const colors = biomeColors[biome] || biomeColors.forest;
        
        // Render platform base with enhanced graphics
        ctx.fillStyle = colors.base;
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        
        // Add texture pattern
        ctx.fillStyle = colors.edge;
        for (let x = 0; x < platform.width; x += 8) {
            for (let y = 0; y < platform.height; y += 8) {
                if ((x + y) % 16 === 0) {
                    ctx.fillRect(platform.x + x, platform.y + y, 4, 4);
                }
            }
        }
        
        // Render grass top
        ctx.fillStyle = colors.grass;
        ctx.fillRect(platform.x, platform.y - 8, platform.width, 8);
        
        // Add grass texture
        ctx.fillStyle = colors.edge;
        for (let x = 0; x < platform.width; x += 4) {
            ctx.fillRect(platform.x + x, platform.y - 6, 2, 2);
        }
        
        // Add highlights
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(platform.x, platform.y, platform.width, 2);
        
        // Add shadows
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(platform.x, platform.y + platform.height - 2, platform.width, 2);
    }
}

// üå≥ DECORATIVE OBJECTS RENDERING
function renderDecoration(x, y, decorationType) {
    // Try to use real decoration sprites first
    let spriteImg = null;
    let spriteSize = 32;
    
    // Choose the right sprite based on decoration type with deterministic variety
    if (decorationType === 'tree') {
        // Use preloaded tree sprites with deterministic selection based on position
        if (preloadedSprites.trees.length > 0) {
            const treeIndex = Math.floor((x + y) / 200) % preloadedSprites.trees.length; // Deterministic based on position
            spriteImg = preloadedSprites.trees[treeIndex];
            spriteSize = 48; // Trees are larger
        }
    } else if (decorationType === 'bush') {
        // Use preloaded bush sprites with deterministic selection
        if (preloadedSprites.bushes.length > 0) {
            const bushIndex = Math.floor((x + y) / 150) % preloadedSprites.bushes.length;
            spriteImg = preloadedSprites.bushes[bushIndex];
            spriteSize = 32; // Bushes are medium
        }
    } else if (decorationType === 'stone') {
        // Use preloaded stone sprites
        if (preloadedSprites.stones.length > 0) {
            spriteImg = preloadedSprites.stones[0];
            spriteSize = 24; // Stones are smaller
        }
    } else if (decorationType === 'mushroom') {
        // Use preloaded mushroom sprites with deterministic selection
        if (preloadedSprites.mushrooms.length > 0) {
            const mushroomIndex = Math.floor((x + y) / 100) % preloadedSprites.mushrooms.length;
            spriteImg = preloadedSprites.mushrooms[mushroomIndex];
            spriteSize = 28; // Mushrooms are small
        }
    }
    
    if (spriteImg && spriteImg.complete && spriteImg.naturalWidth > 0) {
        // Use real decoration sprites
        const centerX = x + (32 - spriteSize) / 2; // Center the sprite
        const centerY = y + (32 - spriteSize) / 2;
        
        ctx.drawImage(
            spriteImg,
            0, 0, spriteImg.naturalWidth, spriteImg.naturalHeight,
            centerX, centerY, spriteSize, spriteSize
        );
    } else {
        // Fallback to simple graphics
        const decorationColors = {
            tree: { body: '#2a6a2a', detail: '#1a4a1a' },
            bush: { body: '#4a7c4a', detail: '#2a6a2a' },
            stone: { body: '#696969', detail: '#4a4a4a' },
            mushroom: { body: '#ff6b6b', detail: '#ff4757' }
        };
        
        const colors = decorationColors[decorationType] || decorationColors.tree;
        
        if (decorationType === 'tree') {
            // Tree trunk
            ctx.fillStyle = colors.detail;
            ctx.fillRect(x + 12, y + 16, 8, 16);
            // Tree leaves
            ctx.fillStyle = colors.body;
            ctx.fillRect(x + 8, y + 8, 16, 12);
            ctx.fillRect(x + 6, y + 4, 20, 8);
        } else if (decorationType === 'bush') {
            // Bush
            ctx.fillStyle = colors.body;
            ctx.fillRect(x + 4, y + 16, 24, 16);
            ctx.fillRect(x + 2, y + 12, 28, 12);
            ctx.fillRect(x, y + 8, 32, 8);
        } else if (decorationType === 'stone') {
            // Stone
            ctx.fillStyle = colors.body;
            ctx.fillRect(x + 8, y + 16, 16, 16);
            ctx.fillRect(x + 6, y + 12, 20, 8);
            // Stone details
            ctx.fillStyle = colors.detail;
            ctx.fillRect(x + 10, y + 18, 4, 4);
            ctx.fillRect(x + 18, y + 20, 4, 4);
        } else if (decorationType === 'mushroom') {
            // Mushroom cap
            ctx.fillStyle = colors.body;
            ctx.fillRect(x + 8, y + 8, 16, 12);
            // Mushroom stem
            ctx.fillStyle = '#f8f8f8';
            ctx.fillRect(x + 14, y + 20, 4, 12);
            // Mushroom spots
            ctx.fillStyle = colors.detail;
            ctx.fillRect(x + 10, y + 10, 4, 4);
            ctx.fillRect(x + 18, y + 12, 4, 4);
        }
    }
}

// üëæ PROFESSIONAL ENEMY RENDERING
function renderProfessionalEnemy(enemy, enemyType = 'bacteria') {
    // Try to use real sprites first
    if (enemySprites && enemySprites.complete && enemySprites.naturalWidth > 0) {
        // Use real mushroom sprite for enemies - use full sprite
        
        ctx.drawImage(
            enemySprites,
            0, 0, enemySprites.naturalWidth, enemySprites.naturalHeight,
            enemy.x, enemy.y, enemy.width, enemy.height
        );
    } else {
        // Enhanced fallback rendering with detailed graphics
        const enemyColors = {
            bacteria: { body: '#00fc00', detail: '#fc0000', outline: '#008000' },
            contra: { body: '#d02020', detail: '#8b0000', outline: '#8b0000' },
            bat: { body: '#2a1a2a', detail: '#fc0000', outline: '#1a0a1a' },
            boss: { body: '#8b0000', detail: '#ffd700', outline: '#4b0000' }
        };
        
        const colors = enemyColors[enemyType] || enemyColors.bacteria;
        
        // Render enemy body
        ctx.fillStyle = colors.outline;
        ctx.fillRect(enemy.x - 1, enemy.y - 1, enemy.width + 2, enemy.height + 2);
        
        ctx.fillStyle = colors.body;
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        
        // Add details based on enemy type
        if (enemyType === 'bacteria') {
            // Eyes
            ctx.fillStyle = colors.detail;
            ctx.fillRect(enemy.x + 4, enemy.y + 4, 3, 3);
            ctx.fillRect(enemy.x + enemy.width - 7, enemy.y + 4, 3, 3);
        } else if (enemyType === 'contra') {
            // Helmet
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(enemy.x + 2, enemy.y + 2, enemy.width - 4, 8);
            // Body armor
            ctx.fillStyle = colors.detail;
            ctx.fillRect(enemy.x + 4, enemy.y + 10, enemy.width - 8, enemy.height - 16);
        } else if (enemyType === 'bat') {
            // Wings
            ctx.fillStyle = colors.outline;
            ctx.fillRect(enemy.x - 4, enemy.y + 4, 8, 4);
            ctx.fillRect(enemy.x + enemy.width - 4, enemy.y + 4, 8, 4);
            // Eyes
            ctx.fillStyle = colors.detail;
            ctx.fillRect(enemy.x + 4, enemy.y + 4, 2, 2);
            ctx.fillRect(enemy.x + enemy.width - 6, enemy.y + 4, 2, 2);
        } else if (enemyType === 'boss') {
            // Crown/helmet
            ctx.fillStyle = colors.detail;
            ctx.fillRect(enemy.x + 2, enemy.y + 2, enemy.width - 4, 6);
            // Armor details
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(enemy.x + 4, enemy.y + 8, enemy.width - 8, enemy.height - 12);
        }
        
        // Add animation effect
        if (enemy.velX !== 0) {
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillRect(enemy.x + 2, enemy.y + 2, 2, enemy.height - 4);
        }
    }
}

let gameRunning = false;
let score = 0;
let level = 1;
let lives = 3;
let cameraX = 0;
let inUnderground = false; // Are we in underground level?
let gameMode = '2d'; // '2d' or 'doom'
const LEVEL_WIDTH = 5200; // Bigger levels! Increased to accommodate secret room at x=4200
let bgMusicInterval = null; // Background music
let blackHole = null; // Black hole after super boss defeat

// üéÆ PROGRESS SYSTEM - Linear progression with keys!
let playerProgress = {
    hasKey1: false,        // –ö–ª—é—á –æ—Ç –ø–æ–¥–∑–µ–º–µ–ª—å—è
    hasKey2: false,        // –ö–ª—é—á –æ—Ç –ö–æ–Ω—Ç—Ä—ã
    undergroundCleared: false,
    contraCleared: false,
    doomCleared: false,
    superBossDefeated: false
};

// Player
const player = {
    x: 100,
    y: 400,
    width: 32,
    height: 32,
    velX: 0,
    velY: 0,
    speed: 5,
    jumping: false,
    jumpPower: 13,
    gravity: 0.6,
    onGround: false,
    doubleJumpAvailable: false,
    hasDoubleJumped: false,
    weapon: 'normal', // normal, spread, laser
    weaponTimer: 0,
    // Animation properties
    animFrame: 0,
    animTimer: 0,
    direction: 1, // 1 = right, -1 = left
    wasOnGround: false, // Track landing
    // Advanced mechanics
    coyoteTime: 0, // Frames after leaving ground
    jumpBuffer: 0, // Frames to remember jump input
    dashing: false,
    dashTime: 0,
    dashCooldown: 0,
    dashDirection: 0,
    // Power-ups
    hasFireball: false,
    fireballTimer: 0,
    hasShield: false,
    shieldTimer: 0,
    hasSuperJump: false,
    superJumpTimer: 0,
    hasSpeedBoots: false,
    speedBootsTimer: 0,
    shootCooldown: 0,
    canShoot: false,
    bullets: []
};

// Combo system
let combo = 0;
let comboTimer = 0;
const COMBO_WINDOW = 120; // 2 seconds at 60fps

// Boss system
let currentBoss = null;
let bossActive = false;
let bossHealthBar = 0;

// Checkpoints
let checkpoints = [];
let lastCheckpoint = { x: 100, y: 400 };

// Power-ups types
const POWERUP_TYPES = {
    FIREBALL: 'fireball',
    SHIELD: 'shield',
    SUPERJUMP: 'superjump',
    SPEEDBOOTS: 'speedboots'
};

// Input
const keys = {};
const keyCodes = {}; // üéÆ Physical keys (works with any keyboard layout!)
document.addEventListener('keydown', (e) => {
    keys[e.key] = true;
    keyCodes[e.code] = true;
    
    
    // Jump with Coyote Time and Input Buffer!
    if (e.key === 'ArrowUp' || e.key === ' ') {
        player.jumpBuffer = 10; // Remember jump input for 10 frames
        
        const currentJumpPower = player.hasSuperJump ? player.jumpPower * 1.4 : player.jumpPower;
        
        if (player.onGround || player.coyoteTime > 0) {
            // First jump (works on ground OR during coyote time!)
            player.velY = -currentJumpPower;
            player.jumping = true;
            player.onGround = false;
            player.coyoteTime = 0; // Used coyote time
            player.doubleJumpAvailable = true;
            player.hasDoubleJumped = false;
            player.jumpBuffer = 0;
            playSound('jump');
        } else if (player.doubleJumpAvailable && !player.hasDoubleJumped) {
            // Double jump!
            player.velY = -currentJumpPower * 0.9;
            player.hasDoubleJumped = true;
            player.doubleJumpAvailable = false;
            player.jumpBuffer = 0;
            playSound('doublejump');
            createParticles(player.x, player.y + player.height, '#fff');
        }
    }
    
    // Dash (Z key) - ‚úÖ –†–ê–ë–û–¢–ê–ï–¢ –í–ï–ó–î–ï! –ò—Å–ø–æ–ª—å–∑—É–µ–º e.code –¥–ª—è –ª—é–±–æ–π —Ä–∞—Å–∫–ª–∞–¥–∫–∏
    if (e.code === 'KeyZ') {
        if (!player.dashing && player.dashCooldown === 0) {
            player.dashing = true;
            player.dashTime = 15; // 0.25 seconds
            player.dashCooldown = 60; // 1 second cooldown
            // Ensure direction is not 0
            player.dashDirection = player.direction !== 0 ? player.direction : 1;
            playSound('dash');
            // Invincible during dash!
            const wasInvincible = player.invincible;
            player.invincible = true;
            setTimeout(() => {
                if (!wasInvincible) player.invincible = false;
            }, 250);
        }
    }
    
    // Shoot (only in Contra mode!)
    // Shoot now handled in update() for continuous shooting
    
    // Change weapon (C key) - –∏—Å–ø–æ–ª—å–∑—É–µ–º e.code –¥–ª—è –ª—é–±–æ–π —Ä–∞—Å–∫–ª–∞–¥–∫–∏
    if (e.code === 'KeyC') {
        if (!player.canShoot) return;
        const weapons = ['normal', 'spread', 'laser'];
        const currentIndex = weapons.indexOf(player.weapon);
        player.weapon = weapons[(currentIndex + 1) % weapons.length];
        playSound('powerup');
    }
});
document.addEventListener('keyup', (e) => {
    keys[e.key] = false;
    keyCodes[e.code] = false;
});

// üñ±Ô∏è MOUSE CONTROLS FOR DOOM MODE!
document.addEventListener('mousemove', (e) => {
    if (gameMode === 'doom' && mouseEnabled && document.pointerLockElement === canvas) {
        // Get mouse movement
        const movementX = e.movementX || e.mozMovementX || 0;
        
        // Rotate player based on mouse movement
        doomPlayer.angle += movementX * mouseSensitivity;
        
        // Keep angle in range [0, 2PI]
        if (doomPlayer.angle < 0) doomPlayer.angle += Math.PI * 2;
        if (doomPlayer.angle > Math.PI * 2) doomPlayer.angle -= Math.PI * 2;
    }
});

// Handle pointer lock change
document.addEventListener('pointerlockchange', () => {
    if (document.pointerLockElement === canvas) {
        mouseEnabled = true;
        console.log('üñ±Ô∏è MOUSE LOCKED! Move mouse to look around');
    } else {
        mouseEnabled = false;
        console.log('üñ±Ô∏è MOUSE UNLOCKED');
    }
});

// Click to shoot in DOOM mode (also re-locks mouse if unlocked)
canvas.addEventListener('click', () => {
    if (gameMode === 'doom') {
        // Re-lock mouse if unlocked
        if (document.pointerLockElement !== canvas) {
            canvas.requestPointerLock();
        }
        
        // Shoot if mouse is locked and has ammo
        if (mouseEnabled && doomPlayer.ammo > 0) {
            doomPlayer.ammo--;
            doomBullets.push({
                x: doomPlayer.x,
                y: doomPlayer.y,
                angle: doomPlayer.angle,
                distance: 0
            });
            playSound('shoot');
            weaponRecoil = 20; // üî´ RECOIL ANIMATION!
            muzzleFlash = 5; // üí• MUZZLE FLASH!
        }
    }
});

// Game objects
let enemies = [];
let powerUps = [];
let blocks = [];
let particles = [];
let coins = [];
let goal = null;
let pipes = []; // New: Warp pipes!
let stars = []; // New: Star power-ups
let gameKeys = []; // üóùÔ∏è NEW: Keys for progression!

// Level platforms
const platforms = [];

// Level configurations
const LEVELS = {
    1: { enemies: 8, pipes: 2, underground: true, bg: '#5c94fc' },
    2: { enemies: 12, pipes: 3, underground: true, bg: '#4080e0' },
    3: { enemies: 15, pipes: 4, underground: true, bg: '#3070d0' },
    4: { enemies: 18, pipes: 5, underground: true, bg: '#2060c0' },
    5: { enemies: 20, pipes: 6, underground: true, bg: '#1050b0' }
};

function initLevel() {
    console.log('üîÑ INITIALIZING MAIN LEVEL...');
    enemies = [];
    powerUps = [];
    blocks = [];
    coins = [];
    particles = [];
    pipes = [];
    stars = [];
    platforms.length = 0;
    inUnderground = false;
    checkpoints = [];
    currentBoss = null;
    bossActive = false;
    console.log('‚úÖ MAIN LEVEL INITIALIZED! inUnderground:', inUnderground);
    
    // ‚úÖ –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –§–ò–ö–° - –æ—á–∏—â–∞–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –≤—Ä–∞–≥–æ–≤!
    if (window.turrets) window.turrets = [];
    if (window.bats) window.bats = [];
    if (window.fallingRocks) window.fallingRocks = [];
    if (window.enemyBullets) window.enemyBullets = [];
    if (window.bossProjectiles) window.bossProjectiles = [];
    if (window.breakableWalls) window.breakableWalls = [];
    if (window.secretRooms) window.secretRooms = [];
    if (window.torches) window.torches = [];
    
    // ‚úÖ –û—Ç–∫–ª—é—á–∞–µ–º —Å—Ç—Ä–µ–ª—å–±—É –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ
    player.canShoot = false;
    player.bullets = [];
    
    const levelConfig = LEVELS[level] || LEVELS[1];
    
    // Ground with GAPS (pits!) - —Ç–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ —É–ø–∞—Å—Ç—å! üíÄ
    // –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —á–∞—Å—Ç–∏ —Å –ø—Ä–æ–ø–∞—Å—Ç—è–º–∏
    let groundX = 0;
    const gapPositions = [800, 1600, 2400, 3200, 4000]; // –ü–æ–∑–∏—Ü–∏–∏ –ø—Ä–æ–ø–∞—Å—Ç–µ–π
    const gapWidth = 150; // –®–∏—Ä–∏–Ω–∞ –ø—Ä–æ–ø–∞—Å—Ç–∏
    
    gapPositions.forEach((gapX, idx) => {
        // –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ –¥–æ –ø—Ä–æ–ø–∞—Å—Ç–∏
        if (gapX > groundX) {
            platforms.push({ 
                x: groundX, 
                y: 550, 
                width: gapX - groundX, 
                height: 50 
            });
        }
        // –°–ª–µ–¥—É—é—â–∏–π —É—á–∞—Å—Ç–æ–∫ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –ø—Ä–æ–ø–∞—Å—Ç–∏
        groundX = gapX + gapWidth;
    });
    
    // –ü–æ—Å–ª–µ–¥–Ω–∏–π –∫—É—Å–æ–∫ –¥–æ –∫–æ–Ω—Ü–∞ —É—Ä–æ–≤–Ω—è
    if (groundX < LEVEL_WIDTH) {
        platforms.push({ 
            x: groundX, 
            y: 550, 
            width: LEVEL_WIDTH - groundX, 
            height: 50 
        });
    }
    
    // === –ù–û–í–û–ï: –ì–û–†–´ –î–õ–Ø –õ–ê–ó–ê–ù–ò–Ø! ===
    const mountains = [];
    for (let i = 0; i < 5; i++) {
        const mountainX = 800 + i * 900;
        const mountainHeight = 200 + i * 30;
        
        // Mountain steps (–ª–µ—Å—Ç–Ω–∏—Ü–∞ –∏–∑ –ø–ª–∞—Ç—Ñ–æ—Ä–º)
        for (let step = 0; step < 8; step++) {
            platforms.push({
                x: mountainX + step * 35,
                y: 550 - step * 28,
                width: 40,
                height: 15,
                isMountain: true
            });
        }
        
        // Summit platform
        platforms.push({
            x: mountainX + 240,
            y: 330,
            width: 120,
            height: 20,
            isSummit: true
        });
        
        mountains.push({
            x: mountainX,
            baseY: 550,
            height: mountainHeight
        });
    }
    
    // Platforms - more complex pattern
    for (let i = 0; i < 30; i++) {
        const pattern = i % 5;
        let y = 450;
        let width = 100;
        
        switch(pattern) {
            case 0: y = 380; width = 120; break;
            case 1: y = 320; width = 80; break;
            case 2: y = 420; width = 100; break;
            case 3: y = 280; width = 60; break; // High platforms!
            case 4: y = 480; width = 140; break;
        }
        
        platforms.push({
            x: 200 + i * 160,
            y: y,
            width: width,
            height: 20
        });
    }
    
    // Add some floating platforms
    for (let i = 0; i < 10; i++) {
        platforms.push({
            x: 300 + i * 450,
            y: 200 + (i % 2) * 50,
            width: 80,
            height: 20
        });
    }
    
    // CHECKPOINTS!
    for (let i = 0; i < 3; i++) {
        checkpoints.push({
            x: 1000 + i * 1200,
            y: 450,
            width: 40,
            height: 100,
            activated: false
        });
    }
    
    // === –ù–û–í–û–ï: –†–ê–ó–ë–ò–í–ê–ï–ú–´–ï –°–¢–ï–ù–´! ===
    if (!window.breakableWalls) window.breakableWalls = [];
    window.breakableWalls = [];
    
    for (let i = 0; i < 8; i++) {
        window.breakableWalls.push({
            x: 600 + i * 550,
            y: 470,
            width: 30,
            height: 80,
            broken: false,
            hits: 0,
            maxHits: 3,
            hasSecret: i % 3 === 0
        });
    }
    
    // === –ù–û–í–û–ï: –°–ï–ö–†–ï–¢–ù–´–ï –ö–û–ú–ù–ê–¢–´! ===
    if (!window.secretRooms) window.secretRooms = [];
    window.secretRooms = [];
    
    // Secret rooms with treasures
    for (let i = 0; i < 3; i++) {
        window.secretRooms.push({
            x: 600 + i * 1650,
            revealed: false,
            entrance: { x: 600 + i * 1650, y: 470 },
            platforms: [
                { x: 550 + i * 1650, y: 350, width: 200, height: 20 },
                { x: 520 + i * 1650, y: 280, width: 100, height: 20 },
                { x: 650 + i * 1650, y: 280, width: 100, height: 20 },
                { x: 580 + i * 1650, y: 210, width: 140, height: 20 }
            ],
            exit: { x: 700 + i * 1650, y: 350 }
        });
    }
    
    // Breakable blocks INTEGRATED into platforms (like Mario!)
    for (let i = 0; i < 15; i++) {
        const platformIndex = i % 30;
        const platform = platforms[platformIndex + 1]; // Skip ground
        if (platform) {
            blocks.push({
                x: platform.x + 30 + (i % 3) * 35,
                y: platform.y - 30, // Integrated with platform
                width: 30,
                height: 30,
                broken: false,
                hasCoin: Math.random() < 0.8,
                bouncing: false,
                bounceOffset: 0
            });
        }
    }
    
    // üóùÔ∏è PROGRESSION PIPES & KEYS!
    
    // Pipe to underground (locked until Key #1)
    pipes.push({
        x: 1000,
        y: 490,
        width: 60,
        height: 60,
        canEnter: playerProgress.hasKey1, // Locked!
        isUnderground: true,
        isContra: false,
        color: '#00fc00',
        locked: !playerProgress.hasKey1
    });
    
    // Pipe to Contra (locked until Key #2)
    pipes.push({
        x: 2000,
        y: 490,
        width: 60,
        height: 60,
        canEnter: playerProgress.hasKey2, // Locked!
        isUnderground: false,
        isContra: true,
        color: '#000',
        locked: !playerProgress.hasKey2
    });
    
    // üóùÔ∏è KEY #1 - Hidden near the end of level
    gameKeys.push({
        x: LEVEL_WIDTH - 400, // Near the end
        y: 350, // On a platform
        width: 24,
        height: 24,
        collected: false,
        type: 'key1', // Key for underground
        glow: 0
    });
    
    // Enemies - distributed in independent groups
    const enemyGroups = Math.ceil(levelConfig.enemies / 3); // 1-3 enemies per group
    for (let group = 0; group < enemyGroups; group++) {
        const groupStartX = 400 + group * 800; // Groups every 800px
        const enemiesInGroup = Math.min(3, levelConfig.enemies - group * 3);
        
        for (let i = 0; i < enemiesInGroup; i++) {
        enemies.push({
                x: groupStartX + i * 200 + Math.random() * 100, // Random offset within group
            y: 510,
            width: 28,
            height: 28,
                velX: (1.5 + level * 0.3) * (Math.random() > 0.5 ? 1 : -1), // Random direction
                alive: true,
                groupId: group, // Track which group this enemy belongs to
                patrolStart: groupStartX + i * 200,
                patrolEnd: groupStartX + i * 200 + 300 // Patrol within 300px
            });
        }
    }
    
    // NEW Power-ups with different types!
    const powerUpTypes = [POWERUP_TYPES.FIREBALL, POWERUP_TYPES.SHIELD, POWERUP_TYPES.SUPERJUMP, POWERUP_TYPES.SPEEDBOOTS];
    for (let i = 0; i < 6; i++) {
        powerUps.push({
            x: 700 + i * 700,
            y: 400,
            width: 24,
            height: 24,
            collected: false,
            type: powerUpTypes[i % powerUpTypes.length]
        });
    }
    
    // NO BOSS in main level - only after completing all areas!
    
    // Stars (invincibility) - place on platforms
    const starPlatforms = [5, 15, 25];
    starPlatforms.forEach(idx => {
        if (platforms[idx]) {
            stars.push({
                x: platforms[idx].x + platforms[idx].width / 2 - 14,
                y: platforms[idx].y - 35,
                width: 28,
                height: 28,
                collected: false
            });
        }
    });
    
    // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–ª–∞—Ç—Ñ–æ—Ä–º—ã –ø–æ—Å–ª–µ –±–æ—Å—Å–∞ –∫ —Ñ–∏–Ω–∏—à—É!
    // –ë–æ—Å—Å –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏ LEVEL_WIDTH - 2000 (2800)
    // –î–æ–±–∞–≤–ª—è–µ–º –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –æ—Ç –±–æ—Å—Å–∞ –∫ —Ñ–ª–∞–≥—É
    
    // 0. –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ –í –∑–æ–Ω–µ –±–æ—Å—Å–∞ (–¥–ª—è –±–æ—è)
    platforms.push({
        x: LEVEL_WIDTH - 2100,
        y: 480,
        width: 200,
        height: 20
    });
    
    platforms.push({
        x: LEVEL_WIDTH - 1850,
        y: 400,
        width: 120,
        height: 20
    });
    
    // 1. –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –∑–æ–Ω—ã –±–æ—Å—Å–∞
    platforms.push({
        x: LEVEL_WIDTH - 1700,
        y: 450,
        width: 150,
        height: 20
    });
    
    // 2. –ü—Ä—ã–∂–∫–æ–≤—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –∫ —Ñ–∏–Ω–∏—à—É
    const goalPlatformsStart = LEVEL_WIDTH - 1500;
    for (let i = 0; i < 5; i++) {
        platforms.push({
            x: goalPlatformsStart + i * 180,
            y: 400 - Math.sin(i * 0.8) * 50, // –í–æ–ª–Ω–æ–æ–±—Ä–∞–∑–Ω—ã–π –ø—É—Ç—å
            width: 120,
            height: 20
        });
    }
    
    // 3. Final platform at the flag
    platforms.push({
        x: LEVEL_WIDTH - 250,
        y: 350,
        width: 200,
        height: 20
    });
    
    // NO GOAL FLAG in main level - only after completing all areas!
    
    // NO DOOM DOOR in main level - only accessible after completing Contra!
}

// BOSS SPAWNING!
function spawnBoss() {
    // –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ —Å–ø–∞–≤–Ω–∞
    if (currentBoss && currentBoss.alive) {
        console.log('‚ö†Ô∏è Boss already exists, skipping spawn');
        return;
    }
    
    // ‚úÖ –§–ò–ö–°: –ë–æ—Å—Å –Ω–∞–º–Ω–æ–≥–æ –±–ª–∏–∂–µ –¥–ª—è –≤–∏–¥–∏–º–æ—Å—Ç–∏!
    // –ë—ã–ª–æ: LEVEL_WIDTH - 1000 = 3800 (—Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ!)
    // –°—Ç–∞–ª–æ: LEVEL_WIDTH - 2000 = 2800 (–±–ª–∏–∂–µ!)
    const bossX = LEVEL_WIDTH - 2000; // –ù–∞–º–Ω–æ–≥–æ –±–ª–∏–∂–µ!
    currentBoss = {
        x: bossX,
        y: 380, // –ù–∏–∂–µ, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –ø—Ä—ã–≥–Ω—É—Ç—å
        width: 80,
        height: 80,
        damageFlash: 0, // –î–ª—è –º–∏–≥–∞–Ω–∏—è –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —É—Ä–æ–Ω–∞
        velX: 0,
        velY: 0,
        health: 20 + level * 5, // Scales with level!
        maxHealth: 20 + level * 5,
        alive: true,
        phase: 1, // Boss phases
        attackTimer: 0,
        moveTimer: 0,
        animFrame: 0,
        damageFlash: 0, // –≠—Ñ—Ñ–µ–∫—Ç —É—Ä–æ–Ω–∞
        type: 'bacteria' // Giant bacteria boss!
    };
    bossHealthBar = currentBoss.maxHealth;
    console.log('üëæ BOSS SPAWNED at x:', bossX, '| health:', currentBoss.health, '| Activate when player.x >', LEVEL_WIDTH - 2500);
}

function createContraLevel(pipeX) {
    const returnX = pipeX;
    
    // Clear everything
    platforms.length = 0;
    enemies.length = 0;
    blocks.length = 0;
    coins.length = 0;
    powerUps.length = 0;
    stars.length = 0;
    
    // ‚úÖ –û—á–∏—â–∞–µ–º –ø–æ–¥–∑–µ–º–Ω—ã—Ö –≤—Ä–∞–≥–æ–≤
    if (window.bats) window.bats = [];
    if (window.fallingRocks) window.fallingRocks = [];
    if (window.torches) window.torches = [];
    if (window.breakableWalls) window.breakableWalls = [];
    if (window.secretRooms) window.secretRooms = [];
    
    // === –†–ê–ó–ë–ò–í–ê–ï–ú–´–ï –°–¢–ï–ù–´ –í CONTRA –†–ï–ñ–ò–ú–ï! ===
    if (!window.breakableWalls) window.breakableWalls = [];
    window.breakableWalls = [];
    
    for (let i = 0; i < 6; i++) {
        window.breakableWalls.push({
            x: 800 + i * 600,
            y: 470,
            width: 30,
            height: 80,
            broken: false,
            hits: 0,
            maxHits: 3,
            hasSecret: i % 2 === 0
        });
    }
    
    inUnderground = 'contra'; // Special mode!
    stopBackgroundMusic();
    startContraMusic();
    
    // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ë–æ–ª—å—à–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º –≤ Contra —Ä–µ–∂–∏–º–µ!
    // Contra ground - —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –∑–µ–º–ª—è
    platforms.push({ x: 0, y: 550, width: 4800, height: 50 }); // –ù–∞ –≤—Å—é —à–∏—Ä–∏–Ω—É —É—Ä–æ–≤–Ω—è!
    
    // Contra platforms (military bases) - –ë–û–õ–¨–®–ï –ü–õ–ê–¢–§–û–†–ú!
    for (let i = 0; i < 20; i++) { // –£–≤–µ–ª–∏—á–∏–ª —Å 10 –¥–æ 20
        platforms.push({
            x: 150 + i * 220,
            y: 450 - (i % 3) * 80,
            width: 100,
            height: 15
        });
    }
    
    // ‚úÖ –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ü–õ–ê–¢–§–û–†–ú–´ –¥–ª—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è!
    // –ü–ª–∞—Ç—Ñ–æ—Ä–º—ã –≤ –∑–æ–Ω–µ –±–æ—Å—Å–∞
    platforms.push({ x: 2700, y: 480, width: 200, height: 20 });
    platforms.push({ x: 2950, y: 400, width: 120, height: 20 });
    
    // –ü–ª–∞—Ç—Ñ–æ—Ä–º—ã –ø–æ—Å–ª–µ –±–æ—Å—Å–∞ –∫ —Ñ–∏–Ω–∏—à—É
    platforms.push({ x: 3100, y: 450, width: 150, height: 20 });
    
    // –ü—Ä—ã–∂–∫–æ–≤—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –∫ —Ñ–∏–Ω–∏—à—É
    for (let i = 0; i < 5; i++) {
        platforms.push({
            x: 3300 + i * 180,
            y: 400 - Math.sin(i * 0.8) * 50,
            width: 120,
            height: 20
        });
    }
    
    // –§–∏–Ω–∞–ª—å–Ω–∞—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞
    platforms.push({ x: 4550, y: 350, width: 200, height: 20 });
    
    // No flag in Contra - only DOOM door leads to exit
    goal = null;
    
    // TURRETS! (like red mushrooms in original Contra)
    if (!window.turrets) window.turrets = [];
    window.turrets = [];
    for (let i = 0; i < 4; i++) { // ‚úÖ –£–º–µ–Ω—å—à–∏–ª —Å 8 –¥–æ 4 —Ç—É—Ä–µ–ª–µ–π
        const platformIdx = i + 2;
        const platform = platforms[platformIdx];
        if (platform) {
            window.turrets.push({
                x: platform.x + platform.width / 2 - 12,
                y: platform.y - 28,
                width: 24,
                height: 28,
                alive: true,
                shootTimer: Math.random() * 60,
                health: 3 // Takes 3 hits!
            });
        }
    }
    
    // Contra enemies (soldiers!) - MORE OF THEM!
    for (let i = 0; i < 15; i++) {
        enemies.push({
            x: 300 + i * 150,
            y: 510,
            width: 28,
            height: 36,
            velX: 2.5,
            alive: true,
            isContra: true,
            shootTimer: Math.random() * 100,
            animFrame: 0
        });
    }
    
    // No exit pipe in Contra - only DOOM door leads to exit
    pipes = [];
    
    // ‚úÖ –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –§–ò–ö–° - –ø—Ä–∞–≤–∏–ª—å–Ω–æ –≤–∫–ª—é—á–∞–µ–º —Å—Ç—Ä–µ–ª—å–±—É!
    player.canShoot = true;
    if (!player.bullets) player.bullets = [];
    player.weapon = 'normal'; // Reset weapon
    
    // üî• DOOM DOOR –í CONTRA –†–ï–ñ–ò–ú–ï!
    doomDoor = {
        x: 4000, // –î–∞–ª—å—à–µ –≤ Contra —Ä–µ–∂–∏–º–µ
        y: 450,
        width: 60,
        height: 100,
        canEnter: true
    };
    
    player.x = 100;
    player.y = 400;
    cameraX = 0;
}

function createUndergroundLevel(pipeX) {
    console.log('üï≥Ô∏è CREATING UNDERGROUND LEVEL! pipeX:', pipeX);
    // Save overworld position
    const returnX = pipeX;
    
    // Clear and create underground
    platforms.length = 0;
    enemies.length = 0;
    blocks.length = 0;
    coins.length = 0;
    if (typeof powerUps !== 'undefined' && powerUps) powerUps.length = 0;
    
    // ‚úÖ –û—á–∏—â–∞–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –≤—Ä–∞–≥–æ–≤
    if (window.turrets) window.turrets = [];
    if (window.enemyBullets) window.enemyBullets = [];
    if (window.bossProjectiles) window.bossProjectiles = [];
    if (window.breakableWalls) window.breakableWalls = [];
    if (window.secretRooms) window.secretRooms = [];
    
    // === –†–ê–ó–ë–ò–í–ê–ï–ú–´–ï –°–¢–ï–ù–´ –í –ü–û–î–ó–ï–ú–ù–û–ú –†–ï–ñ–ò–ú–ï! ===
    if (!window.breakableWalls) window.breakableWalls = [];
    window.breakableWalls = [];
    
    for (let i = 0; i < 5; i++) {
        window.breakableWalls.push({
            x: 600 + i * 400,
            y: 470,
            width: 30,
            height: 80,
            broken: false,
            hits: 0,
            maxHits: 3,
            hasSecret: i % 2 === 0
        });
    }
    
    inUnderground = true;
    startUndergroundMusic(); // Start underground music!
    
    // Underground ground
    platforms.push({ x: 0, y: 550, width: 2000, height: 50 });
    
    // Underground platforms
    for (let i = 0; i < 8; i++) {
        platforms.push({
            x: 100 + i * 200,
            y: 450 - i * 30,
            width: 120,
            height: 20
        });
    }
    
    // Lots of coins in underground!
    for (let i = 0; i < 50; i++) {
        coins.push({
            x: 100 + (i % 10) * 80,
            y: 100 + Math.floor(i / 10) * 60,
            velY: 0,
            collected: false
        });
    }
    
    // Special blocks with guaranteed coins
    for (let i = 0; i < 10; i++) {
        blocks.push({
            x: 200 + i * 150,
            y: 200,
            width: 30,
            height: 30,
            broken: false,
            hasCoin: true
        });
    }
    
    // EPIC UNDERGROUND REDESIGN!
    platforms.length = 0;
    const UNDERGROUND_WIDTH = 3000;
    
    // Ground with lava pits!
    platforms.push({ x: 0, y: 550, width: 400, height: 50 });
    platforms.push({ x: 600, y: 550, width: 400, height: 50 });
    platforms.push({ x: 1200, y: 550, width: 400, height: 50 });
    platforms.push({ x: 1800, y: 550, width: 400, height: 50 });
    platforms.push({ x: 2400, y: 550, width: 600, height: 50 });
    
    // Moving platforms!
    for (let i = 0; i < 5; i++) {
        platforms.push({
            x: 300 + i * 500,
            y: 400 - (i % 2) * 80,
            width: 80,
            height: 15,
            isMoving: true,
            moveSpeed: 2,
            moveRange: 100,
            moveDir: 1,
            startX: 300 + i * 500
        });
    }
    
    // Static platforms
    for (let i = 0; i < 12; i++) {
        platforms.push({
            x: 200 + i * 220,
            y: 350 - (i % 4) * 60,
            width: 60 + Math.random() * 40,
            height: 15
        });
    }
    
    // === –ù–û–í–û–ï: –§–ê–ö–ï–õ–´ –¥–ª—è –æ—Å–≤–µ—â–µ–Ω–∏—è! ===
    if (!window.torches) window.torches = [];
    window.torches = [];
    
    for (let i = 0; i < 15; i++) {
        const platformIdx = 5 + i;
        const platform = platforms[platformIdx];
        if (platform) {
            window.torches.push({
                x: platform.x + platform.width / 2,
                y: platform.y - 40,
                lit: true,
                flicker: 0
            });
        }
    }
    
    // Crystals!
    coins.length = 0;
    for (let i = 0; i < 30; i++) {
        coins.push({
            x: 150 + i * 90,
            y: 150 + (i % 3) * 80,
            velY: 0,
            collected: false,
            isCrystal: true,
            glowPhase: Math.random() * Math.PI * 2
        });
    }
    
    // Crystal blocks
    blocks.length = 0;
    for (let i = 0; i < 8; i++) {
        blocks.push({
            x: 250 + i * 300,
            y: 250 - (i % 2) * 50,
            width: 30,
            height: 30,
            broken: false,
            hasCoin: true,
            bouncing: false,
            bounceOffset: 0
        });
    }
    
    // Bats!
    if (!window.bats) window.bats = [];
    window.bats = [];
    for (let i = 0; i < 8; i++) {
        window.bats.push({
            x: 400 + i * 300,
            y: 200 + Math.random() * 100,
            velX: 1.5,
            velY: Math.sin(i) * 0.5,
            alive: true,
            wingPhase: 0
        });
    }
    
    // Falling rocks!
    if (!window.fallingRocks) window.fallingRocks = [];
    window.fallingRocks = [];
    // –ö–∞–º–Ω–∏ –±–æ–ª—å—à–µ –Ω–µ –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –∑–∞—Ä–∞–Ω–µ–µ - –æ–Ω–∏ –±—É–¥—É—Ç –ø–æ—è–≤–ª—è—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Ä–∞–∑–±–∏–≤–∞–Ω–∏–∏ –ø–æ—Ç–æ–ª–æ—á–Ω—ã—Ö –ø–ª–∏—Ç–æ–∫
    
    // Lava pits!
    if (!window.lavaPits) window.lavaPits = [];
    window.lavaPits = [
        { x: 400, width: 200 },
        { x: 1000, width: 200 },
        { x: 1600, width: 200 }
    ];
    
    // === –°–ï–ö–†–ï–¢: –ø–æ—Ç–æ–ª–æ—á–Ω—ã–µ —Ä–∞–∑—Ä—É—à–∞–µ–º—ã–µ –ø–ª–∏—Ç–∫–∏ –¥–ª—è –ø—Ä–æ—Ö–æ–¥–∞ –Ω–∞–≤–µ—Ä—Ö ===
    if (!window.ceilingTiles) window.ceilingTiles = [];
    window.ceilingTiles = [];
    // –†—è–¥ –ø–ª–∏—Ç –ø–æ –ø–æ—Ç–æ–ª–∫—É (—á—É—Ç—å –Ω–∏–∂–µ –≤–µ—Ä—Ö–∞ —ç–∫—Ä–∞–Ω–∞) –æ—Ç —Å–∞–º–æ–≥–æ —Å—Ç–∞—Ä—Ç–∞ —É—Ä–æ–≤–Ω—è
    const ceilingY = 80; // –≤—ã—Å–æ—Ç–∞ –ø–æ—Ç–æ–ª–∫–∞
    const corridorEnd = 4200; // –¥–æ —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–Ω–∞—Ç—ã
    for (let x = 0; x <= 4500; x += 32) {
        // –û—Å—Ç–∞–≤–∏–º –Ω–µ–±–æ–ª—å—à–æ–π –ø—Ä–æ—ë–º –≤ —Å–∞–º–æ–º –∫–æ–Ω—Ü–µ –¥–ª—è —à–∞—Ö—Ç—ã –≤–Ω–∏–∑ –≤ —Å–µ–∫—Ä–µ—Ç–Ω—É—é
        const isShaftArea = x > corridorEnd - 64; // –ø—Ä–æ—ë–º –¥–ª—è —Å–ø—É—Å–∫–∞ –≤ –∫–æ–Ω—Ü–µ
        window.ceilingTiles.push({
            x: x,
            y: ceilingY,
            width: 32,
            height: 16,
            hits: 0,
            maxHits: 2,
            broken: isShaftArea // –≤ –∑–æ–Ω–µ —à–∞—Ö—Ç—ã –ø–ª–∏—Ç –Ω–µ—Ç (—Å—á–∏—Ç–∞–µ–º —Å–ª–æ–º–∞–Ω–Ω—ã–º–∏)
        });
    }
    
    // === –í–µ—Ä—Ö–Ω–∏–π —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–æ—Ä–∏–¥–æ—Ä (–Ω–∞–¥ –ø–æ—Ç–æ–ª–∫–æ–º) - –¥–æ —Å–∞–º–æ–≥–æ –∫–æ–Ω—Ü–∞ —É—Ä–æ–≤–Ω—è ===
    if (!window.upperCorridor) window.upperCorridor = [];
    window.upperCorridor = [];
    const corridorY = 70; // —á—É—Ç—å –≤—ã—à–µ –ø–æ—Ç–æ–ª–æ—á–Ω—ã—Ö –ø–ª–∏—Ç
    const corridorStartX = 600; // –Ω–∞—á–∏–Ω–∞–µ–º –∫–æ—Ä–∏–¥–æ—Ä –¥–∞–ª—å—à–µ –æ—Ç —Å—Ç–∞—Ä—Ç–∞, —á—Ç–æ–±—ã –Ω–µ –±—Ä–æ—Å–∞–ª—Å—è –≤ –≥–ª–∞–∑–∞
    const corridorEndX = 4200; // –¥–æ —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–Ω–∞—Ç—ã (x=4200)
    for (let x = corridorStartX; x <= corridorEndX; x += 200) {
        // —Ä–µ–¥–∫–∏–µ —Ä–∞–∑—Ä—ã–≤—ã –¥–ª—è –ø—Ä—ã–∂–∫–æ–≤
        const skip = ((x / 200) % 6) === 3; // –∫–∞–∂–¥—ã–π 6-–π –Ω–µ–±–æ–ª—å—à–æ–π —Ä–∞–∑—Ä—ã–≤ (–º–µ–Ω—å—à–µ —Ä–∞–∑—Ä—ã–≤–æ–≤)
        if (!skip) {
            platforms.push({ x: x, y: corridorY, width: 160, height: 12, isUpperCorridor: true });
            window.upperCorridor.push({ x: x, y: corridorY, width: 160, height: 12 });
        }
    }
    
    // –£–±–µ—Ä—ë–º –ª—é–±—ã–µ –≤—ã—Å–æ–∫–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –≤–±–ª–∏–∑–∏ —Å—Ç–∞—Ä—Ç–∞, —á—Ç–æ–±—ã –ø–æ—Ç–æ–ª–æ–∫ –Ω–µ –±—Ä–æ—Å–∞–ª—Å—è –≤ –≥–ª–∞–∑–∞
    for (let i = platforms.length - 1; i >= 0; i--) {
        const p = platforms[i];
        if (p.y <= 120 && p.x < 500) {
            platforms.splice(i, 1);
        }
    }
    
    // === –°–µ–∫—Ä–µ—Ç–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞ —Å —Å–æ–∫—Ä–æ–≤–∏—â–∞–º–∏ –≤ –∫–æ–Ω—Ü–µ –∫–æ—Ä–∏–¥–æ—Ä–∞ ===
    if (!window.secretCorridor) window.secretCorridor = {};
    window.secretCorridor.endX = 4200; // –¥–æ —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–Ω–∞—Ç—ã
    if (!window.secretTreasureRoom) window.secretTreasureRoom = { revealed: false };
    window.secretTreasureRoom = { revealed: false, x: 4200 };
    
    // –°–æ–∑–¥–∞—ë–º –Ω–µ–≤–∏–¥–∏–º—ã–π –±–ª–æ–∫ —Å –≥—Ä–∏–±–æ–º-–∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–º –≤ –Ω–∞—á–∞–ª–µ —É—Ä–æ–≤–Ω—è
    const invisibleBlockX = 300; // –≤ –Ω–∞—á–∞–ª–µ –ø–æ–¥–∑–µ–º–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è
    const invisibleBlockY = 200; // –Ω–∞ –≤—ã—Å–æ—Ç–µ –¥–ª—è –ø—Ä—ã–∂–∫–∞
    platforms.push({
        x: invisibleBlockX,
        y: invisibleBlockY,
        width: 16,
        height: 16,
        isInvisibleBlock: true,
        hits: 0,
        maxHits: 2,
        revealed: false,
        mushroomSpawned: false
    });
    
    // –¢–µ—Å—Ç–æ–≤—ã–π –±–ª–æ–∫ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
    platforms.push({
        x: 500,
        y: 300,
        width: 16,
        height: 16,
        isSecretRoom: true,
        isBrick: true
    });
    console.log('üß™ TEST BRICK ADDED at x=500, y=300');
    
    // –¢–µ—Å—Ç–æ–≤—ã–π —Ä–∞–∑–±–∏–≤–∞—é—â–∏–π—Å—è –±–ª–æ–∫
    platforms.push({
        x: 600,
        y: 300,
        width: 32,
        height: 32,
        isBreakable: true,
        isSecretRoom: true,
        hasCoin: true,
        broken: false,
        breakAnimation: 0
    });
    console.log('üß™ TEST BREAKABLE BLOCK ADDED at x=600, y=300');
    
    // –°–µ–∫—Ä–µ—Ç–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞ –±—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω–∞ –ø–æ–∑–∂–µ, –∫–æ–≥–¥–∞ –∏–≥—Ä–æ–∫ –¥–æ–π–¥–µ—Ç –¥–æ –∫–æ–Ω—Ü–∞ –∫–æ—Ä–∏–¥–æ—Ä–∞
    console.log('üèóÔ∏è SECRET ROOM WILL BE CREATED WHEN PLAYER REACHES END OF CORRIDOR');
    
    // –°–æ–∑–¥–∞—ë–º —Å–µ–∫—Ä–µ—Ç–Ω—É—é –∫–æ–º–Ω–∞—Ç—É —Å —Ä–∞–∑–±–∏–≤–∞—é—â–∏–º–∏—Å—è –±–ª–æ–∫–∞–º–∏ –∏ –º–æ–Ω–µ—Ç–∫–∞–º–∏
    console.log('üèóÔ∏è CREATING BREAKABLE BLOCKS SECRET ROOM at x=4200');
    const entranceX = 4200; // –≤ —Å–∞–º–æ–º –∫–æ–Ω—Ü–µ —É—Ä–æ–≤–Ω—è, –ø–æ—Å–ª–µ —Å—É–ø–µ—Ä –±–æ—Å—Å–∞
    const entranceY = 160; // –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è —à–∞—Ö—Ç–∞ –≤–Ω–∏–∑
    
    // –î–æ–±–∞–≤–∏–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é —à–∞—Ö—Ç—É –∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–Ω–∞—Ç—ã
    platforms.push({ x: entranceX, y: entranceY, width: 20, height: 200, isShaftWall: true });
    
    // –°–µ–∫—Ä–µ—Ç–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞ - –∫–æ–º–Ω–∞—Ç–∞ —Å —Ä–∞–∑–±–∏–≤–∞—é—â–∏–º–∏—Å—è –±–ª–æ–∫–∞–º–∏ –∏ –º–æ–Ω–µ—Ç–∫–∞–º–∏
    const roomY = 360;
    const roomX = entranceX + 30; // –∫–æ–º–Ω–∞—Ç–∞ —Å–ø—Ä–∞–≤–∞ –æ—Ç —à–∞—Ö—Ç—ã
    const roomWidth = 320; // —à–∏—Ä–æ–∫–∞—è –∫–æ–º–Ω–∞—Ç–∞
    const roomHeight = 160; // –≤—ã—Å–æ–∫–∞—è –∫–æ–º–Ω–∞—Ç–∞
    
    // –°–æ–∑–¥–∞—ë–º —Å—Ç–µ–Ω—ã –∫–æ–º–Ω–∞—Ç—ã –∏–∑ –æ–±—ã—á–Ω—ã—Ö –∫–∏—Ä–ø–∏—á–µ–π (–Ω–µ—Ä–∞–∑–±–∏–≤–∞—é—â–∏–µ—Å—è)
    // –ü–æ–ª –∫–æ–º–Ω–∞—Ç—ã
    for (let x = 0; x < roomWidth; x += 32) {
        const brick = { 
            x: roomX + x, 
            y: roomY, 
            width: 32, 
            height: 32, 
            isSecretRoom: true,
            isBrick: true 
        };
        platforms.push(brick);
    }
    
    // –ü–æ—Ç–æ–ª–æ–∫ –∫–æ–º–Ω–∞—Ç—ã
    for (let x = 0; x < roomWidth; x += 32) {
        const brick = { 
            x: roomX + x, 
            y: roomY - roomHeight, 
            width: 32, 
            height: 32, 
            isSecretRoom: true,
            isBrick: true 
        };
        platforms.push(brick);
    }
        
    // –õ–µ–≤–∞—è —Å—Ç–µ–Ω–∞
    for (let y = 0; y < roomHeight; y += 32) {
        const brick = { 
            x: roomX, 
            y: roomY - y, 
            width: 32, 
            height: 32, 
            isSecretRoom: true,
            isBrick: true 
        };
        platforms.push(brick);
    }
    
    // –ü—Ä–∞–≤–∞—è —Å—Ç–µ–Ω–∞
    for (let y = 0; y < roomHeight; y += 32) {
        const brick = { 
            x: roomX + roomWidth - 32, 
            y: roomY - y, 
            width: 32, 
            height: 32, 
            isSecretRoom: true,
            isBrick: true 
        };
        platforms.push(brick);
    }
    
    // === –†–ê–ó–ë–ò–í–ê–Æ–©–ò–ï–°–Ø –ë–õ–û–ö–ò –° –ú–û–ù–ï–¢–ö–ê–ú–ò ===
    // –°–æ–∑–¥–∞—ë–º —Å–µ—Ç–∫—É —Ä–∞–∑–±–∏–≤–∞—é—â–∏—Ö—Å—è –±–ª–æ–∫–æ–≤ —Å –º–æ–Ω–µ—Ç–∫–∞–º–∏ –≤–Ω—É—Ç—Ä–∏
    const breakableBlocks = [];
    
    // –í–µ—Ä—Ö–Ω–∏–π —Ä—è–¥ —Ä–∞–∑–±–∏–≤–∞—é—â–∏—Ö—Å—è –±–ª–æ–∫–æ–≤
    for (let x = 0; x < roomWidth - 64; x += 32) {
        const blockX = roomX + 32 + x;
        const blockY = roomY - 80;
        
        const breakableBlock = {
            x: blockX,
            y: blockY,
            width: 32,
            height: 32,
            isBreakable: true,
            isSecretRoom: true,
            hasCoin: true,
            broken: false,
            breakAnimation: 0
        };
        
        breakableBlocks.push(breakableBlock);
        platforms.push(breakableBlock);
    }
    
    // –°—Ä–µ–¥–Ω–∏–π —Ä—è–¥ —Ä–∞–∑–±–∏–≤–∞—é—â–∏—Ö—Å—è –±–ª–æ–∫–æ–≤
    for (let x = 0; x < roomWidth - 64; x += 32) {
        const blockX = roomX + 32 + x;
        const blockY = roomY - 120;
        
        const breakableBlock = {
            x: blockX,
            y: blockY,
            width: 32,
            height: 32,
            isBreakable: true,
            isSecretRoom: true,
            hasCoin: true,
            broken: false,
            breakAnimation: 0
        };
        
        breakableBlocks.push(breakableBlock);
        platforms.push(breakableBlock);
    }
    
    // –ù–∏–∂–Ω–∏–π —Ä—è–¥ —Ä–∞–∑–±–∏–≤–∞—é—â–∏—Ö—Å—è –±–ª–æ–∫–æ–≤
    for (let x = 0; x < roomWidth - 64; x += 32) {
        const blockX = roomX + 32 + x;
        const blockY = roomY - 40;
        
        const breakableBlock = {
            x: blockX,
            y: blockY,
            width: 32,
            height: 32,
            isBreakable: true,
            isSecretRoom: true,
            hasCoin: true,
            broken: false,
            breakAnimation: 0
        };
        
        breakableBlocks.push(breakableBlock);
        platforms.push(breakableBlock);
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–∞–∑–±–∏–≤–∞—é—â–∏–µ—Å—è –±–ª–æ–∫–∏ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
    window.secretRoomBreakableBlocks = breakableBlocks;
    
    // === –ú–û–ù–ï–¢–ö–ò –í –†–ê–ó–ë–ò–í–ê–Æ–©–ò–•–°–Ø –ë–õ–û–ö–ê–• ===
    // –°–æ–∑–¥–∞—ë–º –º–æ–Ω–µ—Ç–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø—Ä–∏ —Ä–∞–∑–±–∏–≤–∞–Ω–∏–∏ –±–ª–æ–∫–æ–≤
    const coinPositions = [];
    breakableBlocks.forEach(block => {
        coinPositions.push({
            x: block.x + 16, // —Ü–µ–Ω—Ç—Ä –±–ª–æ–∫–∞
            y: block.y + 16,
            blockX: block.x,
            blockY: block.y,
            collected: false,
            isSecretRoomCoin: true
        });
    });
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ –º–æ–Ω–µ—Ç–æ–∫
    window.secretRoomCoins = coinPositions;
    
    // === –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ú–û–ù–ï–¢–ö–ò –í –ö–û–ú–ù–ê–¢–ï ===
    // –†–∞–∑–º–µ—â–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–æ–Ω–µ—Ç–∫–∏ –≤ —Ä–∞–∑–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö –∫–æ–º–Ω–∞—Ç—ã
    const extraCoinPositions = [
        { x: roomX + 50, y: roomY - 60 }, { x: roomX + 100, y: roomY - 60 },
        { x: roomX + 200, y: roomY - 60 }, { x: roomX + 250, y: roomY - 60 },
        { x: roomX + 50, y: roomY - 100 }, { x: roomX + 150, y: roomY - 100 },
        { x: roomX + 250, y: roomY - 100 }, { x: roomX + 100, y: roomY - 140 },
        { x: roomX + 200, y: roomY - 140 }
    ];
    
    extraCoinPositions.forEach(pos => {
        coins.push({
            x: pos.x,
            y: pos.y,
            velY: 0,
            collected: false,
            isCrystal: true,
            glowPhase: Math.random() * Math.PI * 2,
            isSecretRoomCoin: true
        });
    });
    
    // === –†–ï–î–ö–ò–ô –ë–£–°–¢ –í –ö–û–ú–ù–ê–¢–ï ===
    powerUps.push({ 
        x: roomX + 150, 
        y: roomY - 160, 
        width: 24, 
        height: 24, 
        collected: false, 
        type: POWERUP_TYPES.SHIELD,
        isSecretRoom: true
    });
    
    // === –ß–ï–ö–ü–û–ò–ù–¢ –í –ö–û–ú–ù–ê–¢–ï ===
    checkpoints.push({ 
        x: roomX + 150, 
        y: roomY - 60, 
        width: 20, 
        height: 60, 
        activated: false, 
        isSecretFlag: true 
    });
    
    // === –í–ò–ó–£–ê–õ–¨–ù–´–ô –ú–ê–†–ö–ï–† –°–ï–ö–†–ï–¢–ù–û–ô –ö–û–ú–ù–ê–¢–´ ===
    // –î–æ–±–∞–≤–ª—è–µ–º —è—Ä–∫–∏–π –º–∞—Ä–∫–µ—Ä –Ω–∞–¥ —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–Ω–∞—Ç–æ–π –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    window.secretRoomMarker = {
        x: roomX + 150,
        y: roomY - 200,
        width: 100,
        height: 30,
        isSecretRoomMarker: true
    };
    
    // –≠—Ñ—Ñ–µ–∫—Ç—ã
    playSound('star');
    createParticles(entranceX, entranceY, '#fcfc00', 20);
    
    console.log('üèóÔ∏è SECRET ROOM CREATED! Total platforms after:', platforms.length);
    console.log('üèóÔ∏è Secret room position:', roomX, roomY);
    console.log('üèóÔ∏è Room size:', roomWidth, 'x', roomHeight);
    console.log(`üß± –í—Å–µ–≥–æ –∫–∏—Ä–ø–∏—á–µ–π —Å–æ–∑–¥–∞–Ω–æ: ${platforms.filter(p => p.isSecretRoom && p.isBrick).length}`);
    console.log(`üß± –†–∞–∑–±–∏–≤–∞—é—â–∏—Ö—Å—è –±–ª–æ–∫–æ–≤ —Å–æ–∑–¥–∞–Ω–æ: ${platforms.filter(p => p.isBreakable && p.isSecretRoom).length}`);
    console.log(`üí∞ –ú–æ–Ω–µ—Ç–æ–∫ –≤ —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–Ω–∞—Ç–µ: ${window.secretRoomCoins ? window.secretRoomCoins.length : 0}`);
    
    // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–µ—Ä–≤—ã—Ö –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –±–ª–æ–∫–∞—Ö
    const secretRoomBreakableBlocks = platforms.filter(p => p.isBreakable && p.isSecretRoom);
    console.log('üß± –ü–µ—Ä–≤—ã–µ 5 —Ä–∞–∑–±–∏–≤–∞—é—â–∏—Ö—Å—è –±–ª–æ–∫–æ–≤:');
    secretRoomBreakableBlocks.slice(0, 5).forEach((block, i) => {
        console.log(`  Block ${i}: x=${block.x}, y=${block.y}, broken=${block.broken}`);
    });
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–µ–∫—Ä–µ—Ç–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Å–æ–∑–¥–∞–Ω–∞
    console.log('üîç SECRET ROOM VERIFICATION:');
    console.log('  - Room X:', roomX, 'Room Y:', roomY);
    console.log('  - Entrance X:', entranceX, 'Entrance Y:', entranceY);
    console.log('  - Total platforms with isSecretRoom:', platforms.filter(p => p.isSecretRoom).length);
    console.log('  - Total platforms with isBreakable:', platforms.filter(p => p.isBreakable).length);
    console.log('  - Secret room marker created:', !!window.secretRoomMarker);
    
    // Exit pipe
    pipes = [{
        x: 2800,
        y: 490,
        width: 60,
        height: 60,
        canEnter: true,
        isExit: true,
        returnX: returnX,
        color: '#00fc00'
    }];
    
    // === –¢—Ä–∏ –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç–∏ —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ –ø–æ –ø–æ–¥–∑–µ–º–Ω–æ–º—É —É—Ä–æ–≤–Ω—é ===
    powerUps.push({ x: 600, y: 320, width: 24, height: 24, collected: false, type: POWERUP_TYPES.SHIELD });
    powerUps.push({ x: 1500, y: 300, width: 24, height: 24, collected: false, type: POWERUP_TYPES.SHIELD });
    powerUps.push({ x: 2400, y: 320, width: 24, height: 24, collected: false, type: POWERUP_TYPES.SHIELD });
    
    // NO DOOM DOOR in underground - only in Contra!
    
    // üóùÔ∏è KEY #2 will spawn after boss death!
    
    // üè∞ BOSS IN UNDERGROUND!
    spawnBoss();
    
    player.x = 100;
    player.y = 400;
    cameraX = 0;
}

function startGame() {
    document.getElementById('startScreen').style.display = 'none';
    gameRunning = true;
    score = 0;
    level = 1;
    lives = 3;
    player.x = 100;
    player.y = 400;
    cameraX = 0;
    initLevel();
    gameLoop();
}

function restartGame() {
    document.getElementById('gameOverScreen').style.display = 'none';
    startGame();
}

function nextLevel() {
    level++;
    if (level > 5) {
        // Game completed!
        document.getElementById('victoryScreen').style.display = 'none';
        document.getElementById('startScreen').style.display = 'block';
        alert('üéâ CONGRATULATIONS! YOU BEAT ALL 5 LEVELS! üéâ\nFinal Score: ' + score);
        gameRunning = false;
        return;
    }
    document.getElementById('victoryScreen').style.display = 'none';
    player.x = 100;
    player.y = 400;
    cameraX = 0;
    gameRunning = true;
    initLevel();
    gameLoop();
}

function backToMenu() {
    stopBackgroundMusic();
    document.getElementById('victoryScreen').style.display = 'none';
    document.getElementById('startScreen').style.display = 'block';
    gameRunning = false;
}

// –§—É–Ω–∫—Ü–∏—è –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–Ω–∞—Ç—ã
function revealSecretRoom(wallX) {
    if (!window.secretRooms) return;
    
    const room = window.secretRooms.find(r => Math.abs(r.x - wallX) < 100 && !r.revealed);
    if (!room) return;
    
    room.revealed = true;
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –∫–æ–º–Ω–∞—Ç—ã
    room.platforms.forEach(p => {
        platforms.push(p);
    });
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º –∫–æ–º–Ω–∞—Ç—É –º–æ–Ω–µ—Ç–∞–º–∏!
    for (let i = 0; i < 30; i++) {
        coins.push({
            x: room.entrance.x + 20 + (i % 6) * 30,
            y: room.entrance.y - 50 - Math.floor(i / 6) * 40,
            velY: 0,
            collected: false
        });
    }
    
    // –ë–æ–Ω—É—Å–Ω—ã–π power-up!
    powerUps.push({
        x: room.entrance.x + 80,
        y: room.entrance.y - 150,
        width: 24,
        height: 24,
        collected: false,
        type: POWERUP_TYPES.SHIELD
    });
    
    // –ó–≤—É–∫ –æ—Ç–∫—Ä—ã—Ç–∏—è
    playSound('star');
    
    // –≠—Ñ—Ñ–µ–∫—Ç —á–∞—Å—Ç–∏—Ü
    createParticles(room.entrance.x, room.entrance.y, '#fcfc00', 30);
}

// Create path after boss death in underground
function createUndergroundBossPath() {
    if (!inUnderground) return;
    
    console.log('üõ§Ô∏è CREATING UNDERGROUND BOSS PATH!');
    
    // Find boss position and create platforms leading to exit
    const bossX = currentBoss ? currentBoss.x : 2800; // Default boss position
    const startX = bossX + 200; // Start path after boss
    
    // Create platforms leading to the exit pipe
    const pathPlatforms = [
        // Main platform after boss
        { x: startX, y: 450, width: 200, height: 30 },
        
        // Jumping platforms with wavy pattern
        { x: startX + 250, y: 400, width: 100, height: 30 },
        { x: startX + 400, y: 450, width: 100, height: 30 },
        { x: startX + 550, y: 380, width: 100, height: 30 },
        { x: startX + 700, y: 420, width: 100, height: 30 },
        { x: startX + 850, y: 450, width: 150, height: 30 },
        
        // Final platform near exit
        { x: startX + 1050, y: 450, width: 200, height: 30 }
    ];
    
    // Add platforms to the game
    pathPlatforms.forEach(platform => {
        platforms.push(platform);
    });
    
    // Add some crystals on the path
    const crystals = [
        { x: startX + 100, y: 420 },
        { x: startX + 300, y: 370 },
        { x: startX + 500, y: 350 },
        { x: startX + 750, y: 390 },
        { x: startX + 950, y: 420 }
    ];
    
    crystals.forEach(crystal => {
        coins.push({
            x: crystal.x,
            y: crystal.y,
            width: 20,
            height: 20,
            type: 'crystal',
            collected: false,
            glow: 0
        });
    });
    
    console.log('‚úÖ UNDERGROUND BOSS PATH CREATED!', pathPlatforms.length, 'platforms added');
}

// üóùÔ∏è SPAWN KEY #2 AFTER BOSS DEATH!
function spawnKey2AfterBoss() {
    if (!inUnderground) return;
    console.log('üóùÔ∏è SPAWNING KEY #2 AFTER BOSS DEATH!');
    
    // Remove existing key2 if any
    gameKeys = gameKeys.filter(key => key.type !== 'key2');
    
    // Spawn new key2 after boss
    const bossX = currentBoss ? currentBoss.x : 2800;
    gameKeys.push({
        x: bossX + 300, // After boss area
        y: 350, // On a platform
        width: 24,
        height: 24,
        collected: false,
        type: 'key2', // Key for Contra
        glow: 0
    });
    
    console.log('‚úÖ KEY #2 SPAWNED!', gameKeys.length, 'keys total');
}

// üè∞ SUPER BOSS SPAWNING!
function checkAndSpawnSuperBoss() {
    // Check if all areas are cleared
    if (playerProgress.undergroundCleared && 
        playerProgress.contraCleared && 
        playerProgress.doomCleared && 
        !playerProgress.superBossDefeated) {
        
        // Spawn super boss if not already spawned
        if (!currentBoss || !currentBoss.alive) {
            console.log('üè∞ SPAWNING SUPER BOSS! All areas cleared!');
            spawnSuperBoss();
        }
    }
}

// üè∞ SUPER BOSS - Ultimate final boss!
function spawnSuperBoss() {
    currentBoss = {
        x: LEVEL_WIDTH - 200, // At the very end
        y: 300,
        width: 80,
        height: 80,
        velX: 0,
        velY: 0,
        alive: true,
        health: 50, // Much stronger!
        maxHealth: 50,
        attackTimer: 0,
        moveTimer: 0,
        animFrame: 0,
        damageFlash: 0,
        isSuperBoss: true // Special flag
    };
    
    bossActive = false; // Will activate when player approaches
    console.log('üè∞ SUPER BOSS SPAWNED! Health:', currentBoss.health);
}

// üï≥Ô∏è BLACK HOLE - After super boss defeat!
function spawnBlackHole(bossX, bossY) {
    console.log('üï≥Ô∏è SPAWNING BLACK HOLE!');
    
    // Create epic black hole at boss death location
    blackHole = {
        x: bossX - 50, // Center on boss position
        y: bossY - 50,
        width: 100,
        height: 100,
        radius: 50,
        rotation: 0,
        particles: [],
        isActive: true,
        isFinalExit: true
    };
    
    // Create swirling particles around black hole
    for (let i = 0; i < 20; i++) {
        const angle = (i / 20) * Math.PI * 2;
        const distance = 30 + Math.random() * 20;
        blackHole.particles.push({
            x: blackHole.x + 50 + Math.cos(angle) * distance,
            y: blackHole.y + 50 + Math.sin(angle) * distance,
            angle: angle,
            distance: distance,
            speed: 0.1 + Math.random() * 0.1
        });
    }
    
    console.log('‚úÖ BLACK HOLE SPAWNED!');
}

// üï≥Ô∏è ENTER BLACK HOLE - Epic transition!
function enterBlackHole() {
    console.log('üï≥Ô∏è ENTERING BLACK HOLE!');
    
    // Create epic visual effects
    for (let i = 0; i < 50; i++) {
        createParticles(player.x + Math.random() * 40, player.y + Math.random() * 40, '#000000', 20);
    }
    
    // Set black hole message state
    blackHole.messageTimer = 300; // 5 seconds at 60fps
    blackHole.messagePhase = 0; // 0 = entering, 1 = space transition, 2 = prepare for battle
    
    // Enter space mode after message sequence
    setTimeout(() => {
        console.log('üåå TRANSITIONING TO SPACE MODE!');
        initSpaceMode({
            playerHealth: lives * 25, // Convert lives to health
            onExit: (result) => {
                console.log('üåå SPACE MODE RESULT:', result);
                if (result.victory) {
                    // Final victory - complete the game
                    gameRunning = false;
                    stopBackgroundMusic();
                    score += result.score; // Add space score to main score
                    document.getElementById('victoryScore').textContent = score;
                    document.getElementById('victoryScreen').style.display = 'block';
                    playSound('victory');
                } else {
                    // Return to main game
                    gameRunning = true;
                    // Reset player position
                    player.x = 200;
                    player.y = 400;
                    cameraX = 0;
                }
            }
        });
    }, 5000); // 5 seconds total
}

function gameLoop() {
    if (!gameRunning) return;
    update();
    render();
    requestAnimationFrame(gameLoop);
}

function update() {
    // üî• DOOM MODE CHECK - –≤ —Å–∞–º–æ–µ –Ω–∞—á–∞–ª–æ!
    if (gameMode === 'doom') {
        updateDoom();
        return;
    }
    
    // üè∞ CHECK FOR SUPER BOSS SPAWN!
    if (!inUnderground) { // Only in main level
        checkAndSpawnSuperBoss();
    }
    
    // Check DOOM door collision
    checkDoomDoorCollision();
    
    // Track previous ground state for landing detection
    const prevOnGround = player.wasOnGround;
    
    // Update timers
    if (player.coyoteTime > 0) player.coyoteTime--;
    if (player.jumpBuffer > 0) player.jumpBuffer--;
    if (player.dashCooldown > 0) player.dashCooldown--;
    if (comboTimer > 0) {
        comboTimer--;
        if (comboTimer === 0) combo = 0; // Reset combo
    }
    
    // Power-up timers
    if (player.fireballTimer > 0) {
        player.fireballTimer--;
        if (player.fireballTimer === 0) player.hasFireball = false;
    }
    if (player.shieldTimer > 0) {
        player.shieldTimer--;
        if (player.shieldTimer === 0) player.hasShield = false;
    }
    if (player.superJumpTimer > 0) {
        player.superJumpTimer--;
        if (player.superJumpTimer === 0) player.hasSuperJump = false;
    }
    if (player.bigTimer > 0) {
        player.bigTimer--;
        if (player.bigTimer === 0) {
            player.isBig = false;
            player.width = 16; // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—ã—á–Ω—ã–π —Ä–∞–∑–º–µ—Ä
            player.height = 16;
            console.log('üçÑ MUSHROOM ARTIFACT EXPIRED! Cat is normal size again.');
        }
    }
    if (player.speedBootsTimer > 0) {
        player.speedBootsTimer--;
        if (player.speedBootsTimer === 0) player.hasSpeedBoots = false;
    }
    
    // Dash movement (overrides normal movement!)
    if (player.dashing) {
        player.dashTime--;
        player.velX = player.dashDirection * player.speed * 3; // 3x speed!
        player.direction = player.dashDirection; // Update direction during dash
        
        // Dash trail effect
        if (Math.random() < 0.5) {
            particles.push({
                x: player.x + player.width / 2,
                y: player.y + player.height / 2,
                velX: -player.dashDirection * 2,
                velY: (Math.random() - 0.5) * 2,
                color: '#00fcfc',
                life: 20
            });
        }
        
        if (player.dashTime <= 0) {
            player.dashing = false;
        }
    } else {
        // Normal movement
        const currentSpeed = player.hasSpeedBoots ? player.speed * 1.8 : player.speed;
        if (keys['ArrowLeft']) {
            player.velX = -currentSpeed;
            player.direction = -1; // Face left
        } else if (keys['ArrowRight']) {
            player.velX = currentSpeed;
            player.direction = 1; // Face right
        } else {
            player.velX *= 0.8;
        }
        
        // Down movement - go through platforms
        if (keys['ArrowDown'] && player.onGround) {
            player.velY = 2; // Small downward velocity to pass through platforms
        }
    }
    
    // Continuous shooting (Contra mode + Fireball mode!) - üéÆ –∏—Å–ø–æ–ª—å–∑—É–µ–º keyCodes –¥–ª—è –ª—é–±–æ–π —Ä–∞—Å–∫–ª–∞–¥–∫–∏!
    if ((player.canShoot || player.hasFireball) && keyCodes['KeyX']) {
        if (!player.bullets) player.bullets = [];
        
        // Add shooting cooldown to prevent spam
        if (!player.shootCooldown) player.shootCooldown = 0;
        if (player.shootCooldown <= 0) {
            
            // FIREBALL MODE! üî•
            if (player.hasFireball) {
                // Fireball - powerful explosive shot!
                player.bullets.push({
                    x: player.x + player.width,
                    y: player.y + player.height / 2,
                    velX: 8,
                    velY: 0,
                    width: 16,
                    height: 16,
                    type: 'fireball',
                    life: 120 // Longer life
                });
                player.shootCooldown = 15; // Slower fire rate
                playSound('shoot');
            } else
            if (player.weapon === 'spread') {
                // Spread gun - 3 bullets!
                for (let i = -1; i <= 1; i++) {
                    player.bullets.push({
                        x: player.x + player.width,
                        y: player.y + player.height / 2,
                        velX: 10,
                        velY: i * 3,
                        width: 4,
                        height: 4,
                        type: 'spread'
                    });
                }
                player.shootCooldown = 8; // Slower spread
            } else if (player.weapon === 'laser') {
                // Laser - fast single shot
                player.bullets.push({
                    x: player.x + player.width,
                    y: player.y + player.height / 2,
                    velX: 15,
                    velY: 0,
                    width: 8,
                    height: 2,
                    type: 'laser'
                });
                player.shootCooldown = 3; // Very fast laser
            } else {
                // Normal gun
                player.bullets.push({
                    x: player.x + player.width,
                    y: player.y + player.height / 2,
                    velX: 12,
                    velY: 0,
                    width: 6,
                    height: 3,
                    type: 'normal'
                });
                player.shootCooldown = 5; // Normal speed
            }
            playSound('shoot');
        }
        player.shootCooldown--;
    } else {
        player.shootCooldown = 0; // Reset cooldown when not shooting
    }
    
    // Update animation
    if (Math.abs(player.velX) > 0.5 && player.onGround) {
        // Running animation
        player.animTimer++;
        if (player.animTimer > 8) {
            player.animFrame = (player.animFrame + 1) % 3; // 3 frames
            player.animTimer = 0;
        }
    } else {
        // Idle
        player.animFrame = 0;
        player.animTimer = 0;
    }
    
    // Gravity
    player.velY += player.gravity;
    player.x += player.velX;
    player.y += player.velY;
    
    // Camera follow
    if (player.x - cameraX > 400) {
        cameraX = player.x - 400;
    }
    if (player.x - cameraX < 200) {
        cameraX = player.x - 200;
    }
    cameraX = Math.max(0, Math.min(cameraX, LEVEL_WIDTH - canvas.width));
    
    // Debug camera limits for secret room
    if (player.x > 4000) {
        console.log('üì∑ CAMERA DEBUG: player.x=', player.x, 'cameraX=', cameraX, 'max cameraX=', LEVEL_WIDTH - canvas.width, 'canvas.width=', canvas.width);
    }
    
    // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–∞–º–µ—Ä–µ –∏ —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–Ω–∞—Ç–µ
    if (player.x > 4100 && player.x < 4300) {
        console.log('üì∑ CAMERA DEBUG: player.x:', player.x, 'cameraX:', cameraX, 'secret room at x=4200');
        console.log('üì∑ LEVEL_WIDTH:', LEVEL_WIDTH, 'canvas.width:', canvas.width, 'max cameraX:', LEVEL_WIDTH - canvas.width);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–±–∏–≤–∞—é—â–∏–µ—Å—è –±–ª–æ–∫–∏
        if (window.secretRoomBreakableBlocks) {
            console.log('üß± SECRET ROOM BLOCKS:', window.secretRoomBreakableBlocks.length);
            window.secretRoomBreakableBlocks.forEach((block, i) => {
                if (i < 3) { // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 3 –±–ª–æ–∫–∞
                    console.log(`üß± Block ${i}: x=${block.x}, y=${block.y}, broken=${block.broken}`);
                }
            });
        }
    }
    
    // Ground collision & Death by falling! üíÄ
    player.onGround = false;
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–¥–µ–Ω–∏—è –≤ –ø—Ä–æ–ø–∞—Å—Ç—å!
    if (player.y + player.height > 600) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º godmode - –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω, —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏–≥—Ä–æ–∫–∞ –æ–±—Ä–∞—Ç–Ω–æ
        if (player.godMode) {
            console.log('üõ°Ô∏è GODMODE: Player saved from falling!');
            player.x = Math.max(100, player.x - 200); // –¢–µ–ª–µ–ø–æ—Ä—Ç –Ω–∞–∑–∞–¥
            player.y = 400; // –ù–∞ –±–µ–∑–æ–ø–∞—Å–Ω—É—é –≤—ã—Å–æ—Ç—É
            player.velY = 0; // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–∞–¥–µ–Ω–∏–µ
            createParticles(player.x, player.y, '#fcfc00', 15); // –ó–æ–ª–æ—Ç—ã–µ —á–∞—Å—Ç–∏—Ü—ã
        } else {
        // –£–ø–∞–ª –≤ –ø—Ä–æ–ø–∞—Å—Ç—å - —Å–º–µ—Ä—Ç—å!
        lives--;
        playSound('hit');
        createParticles(player.x, 550, '#fc0000', 20);
        
        if (lives <= 0) {
            gameOver();
        } else {
            // –í–æ–∑–≤—Ä–∞—Ç –Ω–∞ checkpoint
            player.x = lastCheckpoint.x;
            player.y = lastCheckpoint.y;
            player.velY = 0;
            player.velX = 0;
            cameraX = Math.max(0, player.x - 400);
            }
        }
    }
    
    // Coyote Time: give grace period after leaving ground
    if (prevOnGround && !player.onGround && !player.jumping && player.y < 600) {
        player.coyoteTime = 6; // 0.1 second grace period
    }
    
    // Landing particles effect
    if (!prevOnGround && player.onGround && player.velY > 3) {
        createParticles(player.x + player.width/2, player.y + player.height, '#aaa', 6);
        playSound('land');
    }
    
    // Input Buffer: if jump was pressed just before landing
    if (player.onGround && player.jumpBuffer > 0 && !prevOnGround) {
        player.velY = -player.jumpPower;
        player.jumping = true;
        player.onGround = false;
        player.doubleJumpAvailable = true;
        player.hasDoubleJumped = false;
        player.jumpBuffer = 0;
        playSound('jump');
    }
    
    player.wasOnGround = player.onGround;
    
    // Platform collision (with moving platforms!)
    platforms.forEach(platform => {
        // Update moving platforms
        if (platform.isMoving) {
            platform.x += platform.moveSpeed * platform.moveDir;
            if (Math.abs(platform.x - platform.startX) > platform.moveRange) {
                platform.moveDir *= -1;
            }
        }
        
        // Check if player is trying to go down through platform
        const tryingToGoDown = keys['ArrowDown'] && player.onGround;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –±–ª–æ–∫ –Ω–µ —Ä–∞–∑–±–∏—Ç (–¥–ª—è —Ä–∞–∑–±–∏–≤–∞—é—â–∏—Ö—Å—è –±–ª–æ–∫–æ–≤)
        const isBlockBroken = platform.isBreakable && platform.broken;
        
        if (!isBlockBroken &&
            player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y + player.height > platform.y &&
            player.y + player.height < platform.y + 20 &&
            player.velY > 0 &&
            !tryingToGoDown) { // Don't land on platform if trying to go down
            player.y = platform.y - player.height;
            player.velY = 0;
            player.onGround = true;
            // Move with platform!
            if (platform.isMoving) {
                player.x += platform.moveSpeed * platform.moveDir;
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ–≤–∏–¥–∏–º–æ–≥–æ –±–ª–æ–∫–∞ —Å –≥—Ä–∏–±–æ–º-–∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–º
        if (platform.isInvisibleBlock) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–¥–∞—Ä–∏–ª –ª–∏ –∏–≥—Ä–æ–∫ –±–ª–æ–∫ —Å–Ω–∏–∑—É
            if (player.x < platform.x + platform.width &&
                player.x + player.width > platform.x &&
                player.y + player.height > platform.y &&
                player.y + player.height < platform.y + 20 &&
                player.velY > 0) {
                
                platform.hits++;
                console.log('üî® INVISIBLE BLOCK HIT! Hits:', platform.hits, '/', platform.maxHits);
                
                // –ü–µ—Ä–≤—ã–π —É–¥–∞—Ä - –±–ª–æ–∫ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –≤–∏–¥–∏–º—ã–º
                if (platform.hits === 1 && !platform.revealed) {
                    platform.revealed = true;
                    console.log('üëÅÔ∏è INVISIBLE BLOCK REVEALED!');
                }
                
                // –í—Ç–æ—Ä–æ–π —É–¥–∞—Ä - —Å–ø–∞–≤–Ω–∏–º –≥—Ä–∏–±-–∞—Ä—Ç–µ—Ñ–∞–∫—Ç
                if (platform.hits >= platform.maxHits && !platform.mushroomSpawned) {
                    platform.mushroomSpawned = true;
                    console.log('üçÑ MUSHROOM ARTIFACT SPAWNED!');
                    
                    // –°–æ–∑–¥–∞—ë–º –≥—Ä–∏–±-–∞—Ä—Ç–µ—Ñ–∞–∫—Ç
                    powerUps.push({
                        x: platform.x,
                        y: platform.y - 24,
                        width: 24,
                        height: 24,
                        collected: false,
                        type: 'MUSHROOM_ARTIFACT',
                        velY: -2, // –ø–æ–¥–ø—Ä—ã–≥–∏–≤–∞–µ—Ç –≤–≤–µ—Ä—Ö
                        velX: 0,
                        isMushroomArtifact: true
                    });
                    
                    // –≠—Ñ—Ñ–µ–∫—Ç—ã
                    playSound('star');
                    createParticles(platform.x + platform.width/2, platform.y, '#ff6b6b', 15);
                }
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–±–∏–≤–∞—é—â–∏—Ö—Å—è –±–ª–æ–∫–æ–≤ –≤ —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–Ω–∞—Ç–µ
        if (platform.isBreakable && platform.isSecretRoom && !platform.broken) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–¥–∞—Ä–∏–ª –ª–∏ –∏–≥—Ä–æ–∫ –±–ª–æ–∫ —Å–Ω–∏–∑—É
            if (player.x < platform.x + platform.width &&
                player.x + player.width > platform.x &&
                player.y + player.height > platform.y &&
                player.y + player.height < platform.y + 20 &&
                player.velY > 0) {
                
                console.log('üí• BREAKABLE BLOCK HIT! Breaking block at x:', platform.x, 'y:', platform.y);
                
                // –†–∞–∑–±–∏–≤–∞–µ–º –±–ª–æ–∫
                platform.broken = true;
                platform.breakAnimation = 10; // –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞–∑–±–∏–≤–∞–Ω–∏—è
                
                // –°–ø–∞–≤–Ω–∏–º –º–æ–Ω–µ—Ç–∫—É –∏–∑ –±–ª–æ–∫–∞
                if (platform.hasCoin && window.secretRoomCoins) {
                    const coin = window.secretRoomCoins.find(c => 
                        Math.abs(c.blockX - platform.x) < 5 && Math.abs(c.blockY - platform.y) < 5
                    );
                    
                    if (coin && !coin.collected) {
                        coin.collected = true;
                        console.log('üí∞ COIN SPAWNED from breakable block!');
                        
                        // –°–æ–∑–¥–∞—ë–º –º–æ–Ω–µ—Ç–∫—É
                        coins.push({
                            x: platform.x + 16,
                            y: platform.y - 20,
                            velY: -3, // –ø–æ–¥–ø—Ä—ã–≥–∏–≤–∞–µ—Ç –≤–≤–µ—Ä—Ö
                            velX: 0,
                            collected: false,
                            isCrystal: true,
                            glowPhase: Math.random() * Math.PI * 2,
                            isSecretRoomCoin: true
                        });
                        
                        // –≠—Ñ—Ñ–µ–∫—Ç—ã
                        playSound('coin');
                        createParticles(platform.x + 16, platform.y, '#FFD700', 10);
                    }
                }
                
                // –≠—Ñ—Ñ–µ–∫—Ç—ã —Ä–∞–∑–±–∏–≤–∞–Ω–∏—è
                playSound('hit');
                createParticles(platform.x + 16, platform.y, '#8B4513', 8);
            }
        }
    });
    
    // Pipe collision - can stand on top!
    pipes.forEach(pipe => {
        if (player.x < pipe.x + pipe.width &&
            player.x + player.width > pipe.x &&
            player.y + player.height > pipe.y &&
            player.y + player.height < pipe.y + 20 &&
            player.velY > 0) {
            player.y = pipe.y - player.height;
            player.velY = 0;
            player.onGround = true;
        }
    });
    
    // Block collision (break from bottom) with BOUNCE effect!
    blocks.forEach(block => {
        // Update bounce animation
        if (block.bouncing) {
            block.bounceOffset = Math.max(0, block.bounceOffset - 1);
            if (block.bounceOffset === 0) {
                block.bouncing = false;
            }
        }
        
        if (!block.broken &&
            player.x < block.x + block.width &&
            player.x + player.width > block.x &&
            player.y < block.y + block.height &&
            player.y + player.height > block.y) {
            
            if (player.velY < 0 && player.y < block.y) {
                // Hit from bottom - MARIO BOUNCE EFFECT!
                block.bouncing = true;
                block.bounceOffset = 8;
                
                if (block.hasCoin) {
                    // Pop coin out
                    coins.push({
                        x: block.x,
                        y: block.y - 40,
                        velY: -10,
                        collected: false
                    });
                    block.hasCoin = false;
                    score += 100;
                    playSound('coin');
                } else {
                    // Break block
                    block.broken = true;
                    score += 50;
                    playSound('break');
                    createParticles(block.x, block.y, '#fc8000');
                }
                
                player.velY = 0;
            } else if (player.velY > 0 && player.y + player.height > block.y) {
                // Landing on top
                player.y = block.y - player.height;
                player.velY = 0;
                player.onGround = true;
            }
        }
    });
    
    // === –ü–æ—Ç–æ–ª–æ—á–Ω—ã–µ –ø–ª–∏—Ç–∫–∏: –∫–æ–ª–ª–∏–∑–∏—è –ø—Ä–∏ —É–¥–∞—Ä–µ –≥–æ–ª–æ–≤–æ–π –≤–≤–µ—Ä—Ö ===
    if (inUnderground && window.ceilingTiles) {
        window.ceilingTiles.forEach(tile => {
            if (tile.broken) return;
            // –±–æ–∫—Å-–∫–æ–ª–ª–∏–∑–∏—è —Å –≤–µ—Ä—Ö–æ–º –∏–≥—Ä–æ–∫–∞: –∏–≥—Ä–æ–∫ –ø–æ–¥–ª–µ—Ç–∞–µ—Ç –∏ –∑–∞–¥–µ–≤–∞–µ—Ç —Å–Ω–∏–∑—É
            const intersects = (
                player.x < tile.x + tile.width &&
                player.x + player.width > tile.x &&
                player.y < tile.y + tile.height &&
                player.y + player.height > tile.y
            );
            if (!intersects) return;
            // –£–¥–∞—Ä –≥–æ–ª–æ–≤–æ–π: –∏–≥—Ä–æ–∫ –¥–≤–∏–≥–∞–µ—Ç—Å—è –≤–≤–µ—Ä—Ö (velY < 0) –∏ –µ–≥–æ –≥–æ–ª–æ–≤–∞ –Ω–∏–∂–µ —Ü–µ–Ω—Ç—Ä–∞ –ø–ª–∏—Ç–∫–∏
            if (player.velY < 0 && (player.y + player.height/2) < (tile.y + tile.height)) {
                tile.hits++;
                playSound('break');
                createParticles(tile.x + tile.width/2, tile.y + tile.height, '#aaaaaa', 8);
                if (tile.hits >= tile.maxHits) {
                    tile.broken = true;
                    // –ü—Ä–∏ –ø–æ–ª–Ω–æ–º —Ä–∞–∑—Ä—É—à–µ–Ω–∏–∏ –ø–ª–∏—Ç–∫–∏ - —Å–ø–∞–≤–Ω–∏–º –∫–∞–º–µ–Ω—å, –∫–æ—Ç–æ—Ä—ã–π –ø–∞–¥–∞–µ—Ç —Å —ç—Ç–æ–≥–æ –º–µ—Å—Ç–∞
                    window.fallingRocks.push({
                        x: tile.x + tile.width/2 - 12,
                        y: tile.y + tile.height,
                        velY: 0,
                        width: 24,
                        height: 24,
                        falling: true,
                        respawnTimer: 0
                    });
                }
                // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å –ø—Ä–∏ —É–¥–∞—Ä–µ
                player.velY = 0;
            }
            // –•–æ–¥—å–±–∞ –ø–æ –ø–ª–∏—Ç–∞–º: –µ—Å–ª–∏ –ø–∞–¥–∞–µ–º —Å–≤–µ—Ä—Ö—É –∏ –Ω–∏–∂–µ –≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü—ã –ø–ª–∏—Ç–∫–∏ ‚Äî —Å—Ç–∞–≤–∏–º –Ω–∞ –ø–ª–∏—Ç—É
            if (player.velY > 0 && (player.y + player.height) <= (tile.y + tile.height) &&
                player.x < tile.x + tile.width && player.x + player.width > tile.x) {
                player.y = tile.y - player.height;
                player.velY = 0;
                player.onGround = true;
            }
        });
    }
    
    // Coins
    coins = coins.filter(coin => {
        if (!coin.collected) {
            coin.velY += 0.5;
            coin.y += coin.velY;
            
            if (checkCollision(player, coin)) {
                coin.collected = true;
                score += 100;
                playSound('coin');
                createParticles(coin.x, coin.y, '#fcfc00');
                return false;
            }
            return coin.y < 600;
        }
        return false;
    });
    
    // üóùÔ∏è KEYS COLLECTION!
    gameKeys = gameKeys.filter(key => {
        if (!key.collected) {
            // Animate key glow
            key.glow += 0.1;
            
            if (checkCollision(player, key)) {
                key.collected = true;
                
                if (key.type === 'key1') {
                    playerProgress.hasKey1 = true;
                    console.log('üóùÔ∏è KEY #1 COLLECTED! Underground unlocked!');
                    playSound('powerup');
                    createParticles(key.x, key.y, '#00ff00');
                    
                    // Unlock underground pipe
                    pipes.forEach(pipe => {
                        if (pipe.isUnderground) {
                            pipe.canEnter = true;
                            pipe.locked = false;
                        }
                    });
                } else if (key.type === 'key2') {
                    playerProgress.hasKey2 = true;
                    console.log('üóùÔ∏è KEY #2 COLLECTED! Contra unlocked!');
                    playSound('powerup');
                    createParticles(key.x, key.y, '#ff0000');
                    
                    // Unlock Contra pipe
                    pipes.forEach(pipe => {
                        if (pipe.isContra) {
                            pipe.canEnter = true;
                            pipe.locked = false;
                        }
                    });
                }
                
                return false;
            }
            return true;
        }
        return false;
    });
    
    // Enemies
    enemies = enemies.filter(enemy => {
        if (!enemy.alive) return false;
        
        enemy.x += enemy.velX;
        
        // Patrol within assigned zone instead of bouncing off edges
        if (enemy.patrolStart !== undefined && enemy.patrolEnd !== undefined) {
            if (enemy.x <= enemy.patrolStart || enemy.x >= enemy.patrolEnd) {
                enemy.velX *= -1;
            }
        } else {
            // Fallback for old enemies without patrol zones
        if (enemy.x < 0 || enemy.x > LEVEL_WIDTH) {
            enemy.velX *= -1;
            }
        }
        
        // Collision with player
        if (checkCollision(player, enemy)) {
            if (player.invincible || player.dashing) {
                // Kill enemy instantly if invincible or dashing!
                enemy.alive = false;
                combo++;
                comboTimer = COMBO_WINDOW;
                const comboBonus = 300 * combo;
                score += comboBonus;
                playSound('stomp');
                createParticles(enemy.x, enemy.y, '#fcfc00');
                return false;
            } else if (player.velY > 0 && player.y < enemy.y) {
                // Stomp enemy
                enemy.alive = false;
                combo++;
                comboTimer = COMBO_WINDOW;
                const comboBonus = 200 * combo;
                score += comboBonus;
                player.velY = -8;
                playSound('stomp');
                createParticles(enemy.x, enemy.y, '#00fc00');
                return false;
            } else {
                // Hit enemy - but shield protects!
                if (player.hasShield) {
                    createParticles(player.x, player.y, '#00fcfc', 10);
                    playSound('break');
                    enemy.alive = false;
                } else {
                    lives--;
                    playSound('hit');
                    createParticles(player.x, player.y, '#fc0000');
                    player.x = Math.max(lastCheckpoint.x, player.x - 50);
                    player.velY = -10;
                    
                    if (lives <= 0) {
                        gameOver();
                    }
                }
            }
        }
        return true;
    });
    
    // Power-ups
    powerUps.forEach(powerUp => {
        if (!powerUp.collected && checkCollision(player, powerUp)) {
            powerUp.collected = true;
            score += 500;
            playSound('powerup');
            createParticles(powerUp.x, powerUp.y, '#fc00fc');
            
            // Apply power-up effect
            switch(powerUp.type) {
                case POWERUP_TYPES.FIREBALL:
                    player.hasFireball = true;
                    player.fireballTimer = 600; // 10 seconds
                    break;
                case POWERUP_TYPES.SHIELD:
                    player.hasShield = true;
                    player.shieldTimer = 900; // 15 seconds
                    break;
                case POWERUP_TYPES.SUPERJUMP:
                    player.hasSuperJump = true;
                    player.superJumpTimer = 600; // 10 seconds
                    break;
                case 'MUSHROOM_ARTIFACT':
                    // –ì—Ä–∏–±-–∞—Ä—Ç–µ—Ñ–∞–∫—Ç —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –∫–æ—Ç–∏–∫–∞ –¥–æ 32x32
                    player.width = 32;
                    player.height = 32;
                    player.isBig = true;
                    player.bigTimer = 1800; // 30 —Å–µ–∫—É–Ω–¥
                    console.log('üçÑ MUSHROOM ARTIFACT COLLECTED! Cat is now BIG!');
                    break;
                case POWERUP_TYPES.SPEEDBOOTS:
                    player.hasSpeedBoots = true;
                    player.speedBootsTimer = 600; // 10 seconds
                    break;
            }
        }
    });
    
    // CHECKPOINTS!
    checkpoints.forEach(checkpoint => {
        if (!checkpoint.activated && checkCollision(player, checkpoint)) {
            checkpoint.activated = true;
            lastCheckpoint = { x: checkpoint.x, y: player.y };
            score += 500;
            playSound('powerup');
            createParticles(checkpoint.x, checkpoint.y, '#00fc00', 20);
            
            // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è —Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ñ–ª–∞–≥–∞
            if (checkpoint.isSecretFlag) {
                playerProgress.secretFound = true;
                console.log('üóùÔ∏è SECRET ROOM DISCOVERED!');
            }
        }
    });
    
    // Pipes - check for entry
    pipes.forEach(pipe => {
        if (checkCollision(player, pipe) && keys['ArrowDown'] && player.onGround) {
            if (pipe.isExit) {
                // Check if this is Contra exit (leads to super boss)
                if (pipe.isContraExit) {
                    console.log('üö™ EXITING CONTRA LEVEL TO SUPER BOSS!');
                stopBackgroundMusic();
                player.canShoot = false;
                player.bullets = [];
                // Clean up Contra-specific objects
                if (window.turrets) window.turrets = [];
                if (window.enemyBullets) window.enemyBullets = [];
                // Clean up DOOM door
                doomDoor = null;
                initLevel();
                    // Move player to super boss area
                    player.x = 3000; // Position near super boss
                cameraX = Math.max(0, player.x - 400);
                    console.log('‚úÖ RETURNED TO MAIN LEVEL FOR SUPER BOSS! Player x:', player.x, 'Camera x:', cameraX);
                playSound('warp');
                } else {
                    // Regular underground exit
                    console.log('üö™ EXITING UNDERGROUND LEVEL!');
                    stopBackgroundMusic();
                    player.canShoot = false;
                    player.bullets = [];
                    // Clean up Contra-specific objects
                    if (window.turrets) window.turrets = [];
                    if (window.enemyBullets) window.enemyBullets = [];
                    // Clean up DOOM door
                    doomDoor = null;
                    initLevel();
                    // Move player to a safe position away from any pipes
                    player.x = 200; // Safe position away from pipes
                    cameraX = Math.max(0, player.x - 400);
                    console.log('‚úÖ RETURNED TO MAIN LEVEL! Player x:', player.x, 'Camera x:', cameraX);
                    playSound('warp');
                }
            } else if (pipe.isContra) {
                // üîí CHECK KEY #2 FOR CONTRA!
                if (playerProgress.hasKey2) {
                    createContraLevel(pipe.x);
                    playSound('warp');
                } else {
                    // Show locked message
                    console.log('üîí CONTRA LOCKED! Need Key #2!');
                    playSound('hit');
                    createParticles(player.x, player.y, '#ff0000', 10);
                }
            } else if (pipe.isUnderground) {
                // üîí CHECK KEY #1 FOR UNDERGROUND!
                console.log('üï≥Ô∏è ENTERING UNDERGROUND! hasKey1:', playerProgress.hasKey1);
                if (playerProgress.hasKey1) {
                    createUndergroundLevel(pipe.x);
                    playSound('warp');
                } else {
                    // Show locked message
                    console.log('üîí UNDERGROUND LOCKED! Need Key #1!');
                    playSound('hit');
                    createParticles(player.x, player.y, '#ff0000', 10);
                }
            }
        }
    });
    
    // –°–µ–∫—Ä–µ—Ç–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞ —Ç–µ–ø–µ—Ä—å —Å–æ–∑–¥–∞–µ—Ç—Å—è —Å—Ä–∞–∑—É –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ –ø–æ–¥–∑–µ–º–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å
    
    // Stars (invincibility power-up)
    stars = stars.filter(star => {
        if (!star.collected && checkCollision(player, star)) {
            star.collected = true;
            score += 1000;
            playSound('star');
            createParticles(star.x, star.y, '#fcfc00');
            player.invincible = true;
            setTimeout(() => player.invincible = false, 10000);
            return false;
        }
        return !star.collected;
    });
    
    // === –ù–û–í–û–ï: –†–∞–∑–±–∏–≤–∞–µ–º—ã–µ —Å—Ç–µ–Ω—ã ===
    if (window.breakableWalls) {
        window.breakableWalls.forEach(wall => {
            if (!wall.broken && checkCollision(player, wall)) {
                // –°–ª–æ–º–∞—Ç—å –¥—ç—à–µ–º!
                if (player.dashing) {
                    wall.hits++;
                    createParticles(wall.x + wall.width/2, wall.y + wall.height/2, '#8b4513', 10);
                    playSound('hit');
                    
                    if (wall.hits >= wall.maxHits) {
                        wall.broken = true;
                        score += 500;
                        playSound('break');
                        createParticles(wall.x + wall.width/2, wall.y + wall.height/2, '#fc8000', 20);
                        
                        // –û—Ç–∫—Ä—ã—Ç—å —Å–µ–∫—Ä–µ—Ç–Ω—É—é –∫–æ–º–Ω–∞—Ç—É!
                        if (wall.hasSecret) {
                            revealSecretRoom(wall.x);
                        }
                    }
                }
            }
            
            // –ü—É–ª–∏ —Ç–æ–∂–µ –ª–æ–º–∞—é—Ç —Å—Ç–µ–Ω—ã (–º–µ–¥–ª–µ–Ω–Ω–µ–µ)
            if (player.bullets && !wall.broken) {
                player.bullets.forEach((bullet, idx) => {
                    if (checkCollision(bullet, wall)) {
                        wall.hits += 0.2; // –ü—É–ª–∏ –º–µ–Ω–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã
                        player.bullets.splice(idx, 1);
                        createParticles(wall.x + wall.width/2, wall.y + wall.height/2, '#8b4513', 3);
                        
                        if (wall.hits >= wall.maxHits) {
                            wall.broken = true;
                            score += 500;
                            playSound('break');
                            if (wall.hasSecret) {
                                revealSecretRoom(wall.x);
                            }
                        }
                    }
                });
            }
        });
    }
    
    // Bullets (Contra mode!)
    if (player.bullets && player.bullets.length > 0) {
        player.bullets = player.bullets.filter(bullet => {
            bullet.x += bullet.velX;
            if (bullet.velY) bullet.y += bullet.velY;
            
            // Check bullet hits enemies
            let hit = false;
            enemies.forEach(enemy => {
                if (enemy.alive && checkCollision(bullet, enemy)) {
                    enemy.alive = false;
                    combo++;
                    comboTimer = COMBO_WINDOW;
                    
                    // Bonus score for fireball!
                    let bonusScore = 500;
                    if (bullet.type === 'fireball') bonusScore = 800; // FIREBALL BONUS! üî•
                    
                    const comboBonus = bonusScore * combo;
                    score += comboBonus;
                    playSound('explosion');
                    
                    // Fireball creates bigger explosion!
                    const particleCount = bullet.type === 'fireball' ? 20 : 10;
                    createParticles(enemy.x, enemy.y, '#fc0000', particleCount);
                    hit = true;
                }
            });
            
            // Check bullet hits turrets
            if (window.turrets) {
                window.turrets.forEach(turret => {
                    if (turret.alive && checkCollision(bullet, turret)) {
                        turret.health--;
                        hit = true;
                        createParticles(turret.x, turret.y, '#fc8000');
                        playSound('hit');
                        
                        if (turret.health <= 0) {
                            turret.alive = false;
                            combo++;
                            comboTimer = COMBO_WINDOW;
                            const comboBonus = 1000 * combo; // Turrets worth more!
                            score += comboBonus;
                            playSound('explosion');
                            createParticles(turret.x + turret.width / 2, turret.y + turret.height / 2, '#fcfc00', 15);
                        }
                    }
                });
            }
            
            // Check bullet hits boss
            if (currentBoss && currentBoss.alive && checkCollision(bullet, currentBoss)) {
                // Damage boss with bullet!
                let damage = 1;
                if (bullet.type === 'laser') damage = 2; // –õ–∞–∑–µ—Ä –¥–µ–ª–∞–µ—Ç –±–æ–ª—å—à–µ —É—Ä–æ–Ω–∞!
                if (bullet.type === 'fireball') damage = 3; // –§–ê–ô–†–ë–û–õ –°–£–ü–ï–† –°–ò–õ–¨–ù–´–ô! üî•
                currentBoss.health -= damage;
                bossHealthBar = currentBoss.health;
                createParticles(bullet.x, bullet.y, '#fc0000', 12); // –ö—Ä–∞—Å–Ω—ã–µ —á–∞—Å—Ç–∏—Ü—ã —É—Ä–æ–Ω–∞
                playSound('hit');
                console.log('üéØ HIT BOSS! Health:', currentBoss.health, '/', currentBoss.maxHealth);
                
                // Flash effect - IMPROVED!
                currentBoss.damageFlash = 15; // Longer flash for bullets
                
                if (currentBoss.health <= 0) {
                    currentBoss.alive = false;
                    bossActive = false;
                    score += 5000;
                    playSound('victory');
                    createParticles(currentBoss.x + 40, currentBoss.y + 40, '#fcfc00', 30);
                    console.log('‚ò†Ô∏è BOSS DEFEATED!');
                    
                    // üè∞ SUPER BOSS DEFEATED!
                    if (currentBoss.isSuperBoss) {
                        playerProgress.superBossDefeated = true;
                        console.log('üè∞ SUPER BOSS DEFEATED! Black hole spawning!');
                        spawnBlackHole(currentBoss.x, currentBoss.y);
                    }
                    
                    // Create path after boss death in underground!
                    if (inUnderground) {
                        createUndergroundBossPath();
                        // üóùÔ∏è SPAWN KEY #2 AFTER BOSS DEATH!
                        spawnKey2AfterBoss();
                    }
                }
                hit = true;
            }
            
            return !hit && bullet.x < cameraX + canvas.width + 100 && bullet.y > 0 && bullet.y < 600;
        });
    }
    
    // Turrets (Contra mode!)
    if (window.turrets) {
        window.turrets.forEach(turret => {
            if (!turret.alive) return;
            
            turret.shootTimer++;
            
            // Shoot at player periodically
            if (turret.shootTimer > 60 && Math.abs(turret.x - player.x) < 400) {
                turret.shootTimer = 0;
                
                // Turret bullet - ‚úÖ –ó–∞–º–µ–¥–ª–∏–ª —Å 5 –¥–æ 3
                if (!window.enemyBullets) window.enemyBullets = [];
                window.enemyBullets.push({
                    x: turret.x + turret.width / 2,
                    y: turret.y + turret.height / 2,
                    velX: player.x > turret.x ? 3 : -3,
                    velY: (player.y - turret.y) / 40,
                    width: 6,
                    height: 6
                });
                playSound('shoot');
            }
        });
    }
    
    // Enemy bullets
    if (window.enemyBullets) {
        window.enemyBullets = window.enemyBullets.filter(bullet => {
            bullet.x += bullet.velX;
            bullet.y += bullet.velY;
            
            // Check hit player
            if (checkCollision(player, bullet) && !player.invincible && !player.dashing) {
                lives--;
                playSound('hit');
                createParticles(player.x, player.y, '#fc0000');
                if (lives <= 0) gameOver();
                return false;
            }
            
            return bullet.x > cameraX - 100 && bullet.x < cameraX + canvas.width + 100 && bullet.y > 0 && bullet.y < 600;
        });
    }
    
    // Goal (legacy flag system)
    if (goal && !blackHole && checkCollision(player, goal)) {
        // Check if boss is defeated
        if (currentBoss && currentBoss.alive) {
            // Boss is still alive - block passage!
            // Show message and push player back
            player.x = Math.max(100, goal.x - 100);
            player.velY = -8;
            createParticles(player.x, player.y, '#ff0000', 15);
            playSound('hit');
        } else {
            // Boss defeated or no boss - level complete!
            victory();
        }
    }
    
    // BOSS LOGIC! üëæ
    // ‚úÖ –§–ò–ö–°: –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º –±–æ—Å—Å–∞ –Ω–∞–º–Ω–æ–≥–æ —Ä–∞–Ω—å—à–µ!
    // –ë—ã–ª–æ: player.x > LEVEL_WIDTH - 1500 = 3300 (—Å–ª–∏—à–∫–æ–º –ø–æ–∑–¥–Ω–æ!)
    // –°—Ç–∞–ª–æ: player.x > LEVEL_WIDTH - 2500 = 2300 (—Ä–∞–Ω—å—à–µ!)
    if (currentBoss && currentBoss.alive && player.x > LEVEL_WIDTH - 2500) {
        if (!bossActive) {
            bossActive = true;
            console.log('‚ö†Ô∏è BOSS BATTLE STARTED! Player x:', player.x);
        }
        currentBoss.animFrame += 0.1;
        currentBoss.attackTimer++;
        currentBoss.moveTimer++;
        
        // Damage flash countdown
        if (currentBoss.damageFlash > 0) {
            currentBoss.damageFlash--;
        }
        
        // Boss movement (floating pattern) - –ò–°–ü–†–ê–í–õ–ï–ù–û!
        currentBoss.moveTimer++;
        if (currentBoss.moveTimer > 30) { // –ß–∞—â–µ –º–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            currentBoss.velX = Math.sin(Date.now() / 500) * 1.5;
            currentBoss.velY = Math.cos(Date.now() / 700) * 1.0;
            currentBoss.moveTimer = 0; // –°–±—Ä–æ—Å —Ç–∞–π–º–µ—Ä–∞
        }
        
        // üêõ DEBUG - –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ
        if (Math.random() < 0.01) {
            console.log('üí™ BOSS MOVING:', 
                'velX:', currentBoss.velX.toFixed(2),
                'velY:', currentBoss.velY.toFixed(2),
                'x:', Math.floor(currentBoss.x),
                'y:', Math.floor(currentBoss.y)
            );
        }
        
        currentBoss.x += currentBoss.velX;
        currentBoss.y += currentBoss.velY;
        
        // Keep boss in bounds (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –¥–ª—è –Ω–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏!)
        currentBoss.x = Math.max(LEVEL_WIDTH - 2200, Math.min(currentBoss.x, LEVEL_WIDTH - 1800));
        currentBoss.y = Math.max(200, Math.min(currentBoss.y, 450));
        
        // Boss attacks every 1 second - –£–õ–£–ß–®–ï–ù–û!
        if (currentBoss.attackTimer > 60) {
            currentBoss.attackTimer = 0;
            // Spawn projectiles towards player
            if (!window.bossProjectiles) window.bossProjectiles = [];
            const angle = Math.atan2(player.y - currentBoss.y, player.x - currentBoss.x);
            for (let i = 0; i < 3; i++) {
                window.bossProjectiles.push({
                    x: currentBoss.x + 40,
                    y: currentBoss.y + 40,
                    velX: Math.cos(angle + (i - 1) * 0.3) * 4,
                    velY: Math.sin(angle + (i - 1) * 0.3) * 4,
                    width: 12,
                    height: 12
                });
            }
            playSound('shoot');
            if (bossActive) {
                console.log('üí• BOSS ATTACK! Projectiles spawned:', 3, '| Boss pos:', Math.floor(currentBoss.x), Math.floor(currentBoss.y));
            }
        }
        
        // Bullets hitting boss now handled in main bullet logic above
        
        // Check player collision with boss
        if (checkCollision(player, currentBoss)) {
            if (player.invincible || player.dashing) {
                // Damage boss with dash/star!
                currentBoss.health -= 2;
                bossHealthBar = currentBoss.health;
                currentBoss.damageFlash = 10;
                createParticles(currentBoss.x, currentBoss.y, '#fc0000', 10);
                playSound('hit');
                console.log('üí• DASH HIT BOSS! Health:', currentBoss.health);
                
                if (currentBoss.health <= 0) {
                    currentBoss.alive = false;
                    score += 5000;
                    playSound('victory');
                    createParticles(currentBoss.x + 40, currentBoss.y + 40, '#fcfc00', 30);
                    
                    // üè∞ SUPER BOSS DEFEATED!
                    if (currentBoss.isSuperBoss) {
                        playerProgress.superBossDefeated = true;
                        console.log('üè∞ SUPER BOSS DEFEATED! Black hole spawning!');
                        spawnBlackHole(currentBoss.x, currentBoss.y);
                    }
                    
                    // Create path after boss death in underground!
                    if (inUnderground) {
                        createUndergroundBossPath();
                        // üóùÔ∏è SPAWN KEY #2 AFTER BOSS DEATH!
                        spawnKey2AfterBoss();
                    }
                }
            } else if (!player.hasShield) {
                lives--;
                playSound('hit');
                createParticles(player.x, player.y, '#fc0000');
                player.x = Math.max(100, player.x - 100);
                player.velY = -10;
                if (lives <= 0) gameOver();
            }
        }
    }
    
    // Boss projectiles
    if (window.bossProjectiles) {
        window.bossProjectiles = window.bossProjectiles.filter(proj => {
            proj.x += proj.velX;
            proj.y += proj.velY;
            
            // Check hit player
            if (checkCollision(player, proj) && !player.invincible && !player.dashing && !player.hasShield) {
                lives--;
                playSound('hit');
                createParticles(player.x, player.y, '#fc0000');
                if (lives <= 0) gameOver();
                return false;
            }
            
            // Shield blocks projectiles
            if (checkCollision(player, proj) && player.hasShield) {
                createParticles(proj.x, proj.y, '#00fcfc', 8);
                playSound('break');
                return false;
            }
            
            return proj.x > cameraX - 100 && proj.x < cameraX + canvas.width + 100 && proj.y > 0 && proj.y < 600;
        });
    }
    
    // Bats (underground enemies!)
    if (window.bats) {
        window.bats = window.bats.filter(bat => {
            if (!bat.alive) return false;
            
            bat.x += bat.velX;
            bat.y += bat.velY;
            bat.wingPhase += 0.2;
            
            // Bounce off walls
            if (bat.x < cameraX || bat.x > cameraX + canvas.width) {
                bat.velX *= -1;
            }
            if (bat.y < 50 || bat.y > 400) {
                bat.velY *= -1;
            }
            
            // Collision with player
            if (checkCollision(player, bat)) {
                if (!player.invincible && !player.dashing) {
                    lives--;
                    playSound('hit');
                    createParticles(player.x, player.y, '#fc0000');
                    bat.alive = false;
                    if (lives <= 0) gameOver();
                } else {
                    bat.alive = false;
                    combo++;
                    comboTimer = COMBO_WINDOW;
                    const comboBonus = 300 * combo;
                    score += comboBonus;
                    playSound('stomp');
                    createParticles(bat.x, bat.y, '#fcfc00');
                }
                return false;
            }
            return true;
        });
    }
    
    // Falling rocks! (—Ç–µ–ø–µ—Ä—å –ø–∞–¥–∞—é—Ç —Ç–æ–ª—å–∫–æ —Å —Ä–∞–∑–±–∏—Ç—ã—Ö –ø–æ—Ç–æ–ª–æ—á–Ω—ã—Ö –ø–ª–∏—Ç–æ–∫)
    if (window.fallingRocks) {
        window.fallingRocks.forEach(rock => {
            // –ö–∞–º–Ω–∏ —É–∂–µ –ø–∞–¥–∞—é—Ç —Å –º–æ–º–µ–Ω—Ç–∞ —Å–ø–∞–≤–Ω–∞ –ø—Ä–∏ —Ä–∞–∑–±–∏–≤–∞–Ω–∏–∏ –ø–ª–∏—Ç–∫–∏
            
            if (rock.falling) {
                rock.velY += 0.5;
                rock.y += rock.velY;
                
                // Check collision with player
                // –î–æ–ø. –∑–∞—â–∏—Ç–∞: –µ—Å–ª–∏ –∏–≥—Ä–æ–∫ —Å—Ç–æ–∏—Ç –Ω–∞ –ø–æ—Ç–æ–ª–æ—á–Ω–æ–π –ø–ª–∏—Ç–∫–µ, –∫–∞–º–µ–Ω—å –Ω–µ –Ω–∞–Ω–æ—Å–∏—Ç —É—Ä–æ–Ω
                const playerOnCeilingNow = window.ceilingTiles && window.ceilingTiles.some(t => !t.broken &&
                    (player.x + player.width * 0.3) < (t.x + t.width) &&
                    (player.x + player.width * 0.7) > t.x &&
                    Math.abs((player.y + player.height) - t.y) <= 8);
                if (playerOnCeilingNow && rock.y < player.y) {
                    // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –ø–æ–¥ –∑–∞—â–∏—Ç–æ–π –ø–ª–∏—Ç–∫–∏, –∫–∞–º–µ–Ω—å —Ä–∞—Å—Å–µ–∏–≤–∞–µ—Ç—Å—è/—Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç—Å—è –±–µ–∑ —É—Ä–æ–Ω–∞
                    rock.falling = false;
                    rock.y = 0;
                    rock.velY = 0;
                } else if (!playerOnCeilingNow && checkCollision(player, rock)) {
                    if (!player.invincible && !player.godMode) {
                        lives--;
                        playSound('hit');
                        createParticles(player.x, player.y, '#fc0000');
                        rock.falling = false;
                        rock.y = 0;
                        rock.velY = 0;
                        if (lives <= 0) gameOver();
                    } else if (player.godMode) {
                        // –í godmode –∫–∞–º–Ω–∏ –ø—Ä–æ—Å—Ç–æ –∏—Å—á–µ–∑–∞—é—Ç –ø—Ä–∏ –∫–∞—Å–∞–Ω–∏–∏
                        console.log('üõ°Ô∏è GODMODE: Rock destroyed on contact!');
                        rock.falling = false;
                        rock.y = 0;
                        rock.velY = 0;
                        createParticles(player.x, player.y, '#fcfc00', 10);
                    }
                }
                
                // Reset if hit ground
                if (rock.y > 550) {
                    rock.falling = false;
                    rock.y = 0;
                    rock.velY = 0;
                    rock.respawnTimer = 100;
                }
            }
            
            if (!rock.falling && rock.respawnTimer > 0) {
                rock.respawnTimer--;
            }
        });
    }
    
    // Lava pits (instant death!)
    if (window.lavaPits && inUnderground) {
        window.lavaPits.forEach(pit => {
            if (player.x + player.width > pit.x &&
                player.x < pit.x + pit.width &&
                player.y + player.height > 550) {
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º godmode - –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω, –∏–≥—Ä–æ–∫ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç —É—Ä–æ–Ω –æ—Ç –ª–∞–≤—ã
                if (player.godMode) {
                    console.log('üõ°Ô∏è GODMODE: Player protected from lava!');
                    // –¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏–≥—Ä–æ–∫–∞ –Ω–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ –º–µ—Å—Ç–æ
                    player.x = pit.x + pit.width + 50; // –†—è–¥–æ–º —Å –ª–∞–≤–æ–π
                    player.y = 400; // –ù–∞ –±–µ–∑–æ–ø–∞—Å–Ω—É—é –≤—ã—Å–æ—Ç—É
                    player.velY = 0; // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–∞–¥–µ–Ω–∏–µ
                    createParticles(player.x, player.y, '#fcfc00', 15); // –ó–æ–ª–æ—Ç—ã–µ —á–∞—Å—Ç–∏—Ü—ã
                } else {
                // Fell in lava!
                lives--;
                playSound('hit');
                createParticles(player.x, player.y, '#fc8000');
                player.x = 100;
                player.y = 400;
                cameraX = 0;
                if (lives <= 0) gameOver();
                }
            }
        });
    }
    
    // üï≥Ô∏è BLACK HOLE UPDATE
    if (blackHole && blackHole.isActive) {
        // Rotate black hole
        blackHole.rotation += 0.1;
        
        // Update message timer
        if (blackHole.messageTimer > 0) {
            blackHole.messageTimer--;
            
            // Phase transitions
            if (blackHole.messageTimer === 200) {
                blackHole.messagePhase = 1; // Congratulations
            } else if (blackHole.messageTimer === 100) {
                blackHole.messagePhase = 2; // Final score
            }
        }
        
        // Update swirling particles
        blackHole.particles.forEach(particle => {
            particle.angle += particle.speed;
            particle.distance = Math.max(10, particle.distance - 0.2); // Slowly spiral inward
            
            particle.x = blackHole.x + 50 + Math.cos(particle.angle) * particle.distance;
            particle.y = blackHole.y + 50 + Math.sin(particle.angle) * particle.distance;
            
            // Reset particle if it gets too close
            if (particle.distance < 10) {
                particle.distance = 50;
                particle.angle += Math.PI;
            }
        });
        
        // Check collision with player (only if not showing message)
        if (blackHole.messageTimer === undefined && checkCollision(player, blackHole)) {
            console.log('üï≥Ô∏è PLAYER ENTERED BLACK HOLE!');
            enterBlackHole();
        }
    }
    
    // === –°–µ–∫—Ä–µ—Ç–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞: –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å —Ä—ã—á–∞–≥–æ–º –∏ —Å—É–Ω–¥—É–∫–æ–º ===
    if (inUnderground && window.secretTreasureRoom && window.secretTreasureRoom.revealed) {
        // –†—ã—á–∞–≥
        if (window.secretTreasureRoom.lever && !window.secretTreasureRoom.lever.activated) {
            if (checkCollision(player, window.secretTreasureRoom.lever) && keys['ArrowDown']) {
                window.secretTreasureRoom.lever.activated = true;
                window.secretTreasureRoom.lever.activationTimer = 300; // 5 —Å–µ–∫—É–Ω–¥
                playSound('powerup');
                createParticles(window.secretTreasureRoom.lever.x, window.secretTreasureRoom.lever.y, '#fcfc00', 15);
                console.log('üîß LEVER ACTIVATED!');
            }
        }
        
        // –°—É–Ω–¥—É–∫ (–æ—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ —Ä—ã—á–∞–≥–∞)
        if (window.secretTreasureRoom.chest && !window.secretTreasureRoom.chest.opened && 
            window.secretTreasureRoom.lever && window.secretTreasureRoom.lever.activated) {
            if (checkCollision(player, window.secretTreasureRoom.chest) && keys['ArrowDown']) {
                window.secretTreasureRoom.chest.opened = true;
                window.secretTreasureRoom.chestOpened = true;
                score += 2000;
                playSound('star');
                createParticles(window.secretTreasureRoom.chest.x, window.secretTreasureRoom.chest.y, '#fcfc00', 25);
                
                // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ª—É—Ç –∏–∑ —Å—É–Ω–¥—É–∫–∞
                powerUps.push({ 
                    x: window.secretTreasureRoom.chest.x + 5, 
                    y: window.secretTreasureRoom.chest.y - 30, 
                    width: 24, height: 24, 
                    collected: false, 
                    type: POWERUP_TYPES.FIREBALL 
                });
                console.log('üí∞ TREASURE CHEST OPENED!');
            }
        }
        
        // –¢–∞–π–º–µ—Ä —Ä—ã—á–∞–≥–∞
        if (window.secretTreasureRoom.lever && window.secretTreasureRoom.lever.activated) {
            window.secretTreasureRoom.lever.activationTimer--;
            if (window.secretTreasureRoom.lever.activationTimer <= 0) {
                window.secretTreasureRoom.lever.activated = false;
                console.log('üîß LEVER DEACTIVATED!');
            }
        }
    }
    
    // Particles
    particles = particles.filter(p => {
        p.x += p.velX;
        p.y += p.velY;
        p.life--;
        return p.life > 0;
    });
    
    // Update HUD
    document.getElementById('scoreDisplay').textContent = score;
    document.getElementById('livesDisplay').textContent = lives;
    document.getElementById('levelDisplay').textContent = level;
    
    // Update dash display
    const dashStatus = document.getElementById('dashStatus');
    const dashDisplay = document.getElementById('dashDisplay');
    if (player.dashing) {
        dashStatus.textContent = 'DASHING!';
        dashStatus.style.color = '#00fcfc';
    } else if (player.dashCooldown > 0) {
        const cooldownSec = Math.ceil(player.dashCooldown / 60);
        dashStatus.textContent = cooldownSec + 's';
        dashStatus.style.color = '#fc8000';
    } else {
        dashStatus.textContent = 'READY';
        dashStatus.style.color = '#00fc00';
    }
    
    // Update weapon display
    if (player.canShoot) {
        document.getElementById('weaponDisplay').style.display = 'block';
        let weaponText = player.weapon.toUpperCase();
        // Show turret count in Contra mode
        if (window.turrets) {
            const turretsAlive = window.turrets.filter(t => t.alive).length;
            if (turretsAlive > 0) {
                weaponText += ` | üçÑ${turretsAlive}`;
            }
        }
        document.getElementById('weaponType').textContent = weaponText;
    } else {
        document.getElementById('weaponDisplay').style.display = 'none';
    }
}

function render() {
    // üßπ CLEAR CANVAS - fix sprite trails!
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // üî• DOOM RENDERING - –≤ —Å–∞–º–æ–µ –Ω–∞—á–∞–ª–æ!
    if (gameMode === 'doom') {
        renderDoom();
        return;
    }
    
    ctx.save();
    ctx.translate(-cameraX, 0);
    
    // Background - changes for special modes
    if (inUnderground === 'contra') {
        // CONTRA MODE - EPIC JUNGLE WARFARE!
        // Sky gradient (deeper jungle feel)
        const gradient = ctx.createLinearGradient(0, 0, 0, 400);
        gradient.addColorStop(0, '#0a3a2a');
        gradient.addColorStop(0.5, '#1a4a3a');
        gradient.addColorStop(1, '#2a5a4a');
        ctx.fillStyle = gradient;
        ctx.fillRect(cameraX, 0, canvas.width, 400);
        
        // Ground gradient
        const groundGrad = ctx.createLinearGradient(0, 400, 0, 600);
        groundGrad.addColorStop(0, '#3a2a1a');
        groundGrad.addColorStop(1, '#2a1a0a');
        ctx.fillStyle = groundGrad;
        ctx.fillRect(cameraX, 400, canvas.width, 200);
        
        // STARS in night sky
        ctx.fillStyle = '#fcfcfc';
        for (let i = 0; i < 30; i++) {
            const starX = (i * 123) % 800 + cameraX;
            const starY = (i * 79) % 150;
            const twinkle = Math.sin(Date.now() / 300 + i) * 0.5 + 0.5;
            ctx.globalAlpha = twinkle;
            ctx.fillRect(starX, starY, 2, 2);
        }
        ctx.globalAlpha = 1;
        
        // BACKGROUND LAYER - Far trees
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#1a3a2a';
        for (let i = 0; i < 20; i++) {
            const x = cameraX + i * 120 - 50;
            // Distant tree trunks
            ctx.fillRect(x, 150, 15, 200);
            // Distant leaves
            ctx.fillRect(x - 10, 140, 35, 30);
        }
        ctx.globalAlpha = 1;
        
        // MIDDLE LAYER - Detailed palm trees
        for (let i = 0; i < 15; i++) {
            const treeX = i * 160 + 50;
            
            // Tree trunk with detailed texture
            ctx.fillStyle = '#5a3a1a';
            ctx.fillRect(treeX, 180, 24, 180);
            
            // Trunk texture - horizontal lines
            ctx.fillStyle = '#4a2a0a';
            for (let j = 0; j < 18; j++) {
                ctx.fillRect(treeX + 2, 180 + j * 10, 20, 4);
                ctx.fillRect(treeX + 4, 182 + j * 10, 16, 2);
            }
            
            // Trunk highlights
            ctx.fillStyle = '#6a4a2a';
            ctx.fillRect(treeX + 2, 180, 3, 180);
            
            // Palm leaves - DETAILED!
            ctx.fillStyle = '#2a6a2a';
            
            // Left leaves (multiple layers)
            for (let j = 0; j < 6; j++) {
                const leafY = 170 - j * 10;
                const leafWidth = 50 - j * 6;
                ctx.fillRect(treeX - 35 + j * 6, leafY, leafWidth, 10);
                // Leaf segments
                ctx.fillStyle = '#3a7a3a';
                for (let k = 0; k < 5; k++) {
                    ctx.fillRect(treeX - 35 + j * 6 + k * 8, leafY + 2, 6, 6);
                }
                ctx.fillStyle = '#2a6a2a';
            }
            
            // Right leaves
            for (let j = 0; j < 6; j++) {
                const leafY = 170 - j * 10;
                const leafWidth = 50 - j * 6;
                ctx.fillRect(treeX + 10 - j * 3, leafY, leafWidth, 10);
                // Leaf segments
                ctx.fillStyle = '#3a7a3a';
                for (let k = 0; k < 5; k++) {
                    ctx.fillRect(treeX + 10 - j * 3 + k * 8, leafY + 2, 6, 6);
                }
                ctx.fillStyle = '#2a6a2a';
            }
            
            // Center top leaves
            for (let j = 0; j < 5; j++) {
                const leafY = 150 - j * 12;
                const leafWidth = 20 - j * 3;
                ctx.fillRect(treeX + 4 + j * 2, leafY, leafWidth, 12);
            }
            
            // Bright highlights on leaves
            ctx.fillStyle = '#4a9a4a';
            ctx.fillRect(treeX - 20, 175, 35, 3);
            ctx.fillRect(treeX + 12, 175, 35, 3);
            ctx.fillRect(treeX + 8, 158, 12, 3);
        }
        
        // HANGING VINES!
        ctx.fillStyle = '#2a5a2a';
        for (let i = 0; i < 25; i++) {
            const vineX = cameraX + i * 90 + 30;
            const vineLength = 80 + (i % 3) * 40;
            const swing = Math.sin(Date.now() / 500 + i) * 3;
            
            // Vine rope
            for (let j = 0; j < vineLength / 8; j++) {
                const y = j * 8;
                const x = vineX + Math.sin(j * 0.3) * 2 + swing;
                ctx.fillRect(x, y, 3, 8);
                // Vine leaves
                if (j % 3 === 0) {
                    ctx.fillRect(x - 4, y, 8, 4);
                }
            }
        }
        
        // FOREGROUND - Static bushes (no camera movement)
        ctx.fillStyle = '#1a5a1a';
        const staticBushes = [200, 800, 1400, 2200, 3000, 3800, 4600, 5400]; // Fixed positions
        staticBushes.forEach(bushX => {
            // Only render if bush is visible on screen
            if (bushX > cameraX - 100 && bushX < cameraX + canvas.width + 100) {
            // Big bush
                ctx.fillRect(bushX - cameraX, 360, 70, 40);
                ctx.fillRect(bushX - cameraX + 10, 350, 50, 15);
                ctx.fillRect(bushX - cameraX + 20, 345, 30, 8);
            
            // Bush highlights
            ctx.fillStyle = '#2a7a2a';
                ctx.fillRect(bushX - cameraX + 15, 355, 40, 8);
                ctx.fillRect(bushX - cameraX + 25, 348, 20, 4);
            ctx.fillStyle = '#1a5a1a';
        }
        });
        
        // Grass blades in foreground - static
        ctx.fillStyle = '#3a8a3a';
        const staticGrass = [150, 350, 650, 950, 1250, 1550, 1850, 2150, 2450, 2750, 3050, 3350, 3650, 3950, 4250]; // Fixed positions
        staticGrass.forEach(grassX => {
            // Only render if grass is visible on screen
            if (grassX > cameraX - 50 && grassX < cameraX + canvas.width + 50) {
                ctx.fillRect(grassX - cameraX, 390, 4, 10);
                ctx.fillRect(grassX - cameraX + 2, 385, 3, 10);
            }
        });
        
        // FIREFLIES/GLOWING PARTICLES for atmosphere!
        const time = Date.now() / 200;
        for (let i = 0; i < 15; i++) {
            const flyX = cameraX + i * 150 + Math.sin(time + i) * 30;
            const flyY = 100 + i * 30 + Math.cos(time * 0.5 + i) * 40;
            const glow = 0.3 + Math.sin(time * 2 + i) * 0.7;
            
            ctx.globalAlpha = glow;
            ctx.fillStyle = '#fcfc00';
            ctx.fillRect(flyX, flyY, 3, 3);
            // Glow effect
            ctx.globalAlpha = glow * 0.3;
            ctx.fillRect(flyX - 2, flyY - 2, 7, 7);
            ctx.globalAlpha = 1;
        }
    } else if (inUnderground) {
        // EPIC UNDERGROUND with LAVA!
        // MUCH LIGHTER cave background for better visibility
        const gradient = ctx.createLinearGradient(0, 0, 0, 600);
        gradient.addColorStop(0, '#4a4a4a');  // Much lighter top
        gradient.addColorStop(0.5, '#5a4a4a'); // Lighter middle
        gradient.addColorStop(1, '#6a4a40');   // Lighter bottom
        ctx.fillStyle = gradient;
        ctx.fillRect(cameraX, 0, canvas.width, canvas.height);
        
        // Stalactites (hanging from ceiling)
        ctx.fillStyle = '#3a3a3a';
        for (let i = 0; i < 30; i++) {
            const x = cameraX - 100 + i * 100;
            const height = 40 + (i % 3) * 20;
            // Main stalactite
            ctx.fillRect(x, 0, 20, height);
            ctx.fillRect(x + 3, 0, 14, height - 10);
            ctx.fillRect(x + 6, 0, 8, height - 20);
            // Tip
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(x + 8, height - 5, 4, 5);
            ctx.fillStyle = '#3a3a3a';
        }
        
        // Stalagmites (rising from ground)
        ctx.fillStyle = '#4a4a4a';
        for (let i = 0; i < 25; i++) {
            const x = cameraX - 50 + i * 120;
            const height = 30 + (i % 4) * 15;
            const y = 550 - height;
            // Main stalagmite
            ctx.fillRect(x, y, 18, height);
            ctx.fillRect(x + 3, y + 10, 12, height - 10);
            ctx.fillRect(x + 6, y + 20, 6, height - 20);
            // Highlight
            ctx.fillStyle = '#5a5a5a';
            ctx.fillRect(x + 2, y + 5, 3, height - 10);
            ctx.fillStyle = '#4a4a4a';
        }
        
        // Lava pits with animation!
        if (window.lavaPits) {
            const lavaTime = Date.now() / 100;
            window.lavaPits.forEach(pit => {
                // Lava glow
                ctx.fillStyle = '#fc4000';
                ctx.fillRect(pit.x, 550, pit.width, 50);
                
                // Animated lava surface
                ctx.fillStyle = '#fc8000';
                for (let i = 0; i < pit.width / 20; i++) {
                    const wave = Math.sin(lavaTime + i) * 3;
                    ctx.fillRect(pit.x + i * 20, 550 + wave, 20, 10);
                }
                
                // Bright spots
                ctx.fillStyle = '#fcfc00';
                for (let i = 0; i < pit.width / 40; i++) {
                    const wave = Math.sin(lavaTime * 2 + i * 2) * 2;
                    ctx.fillRect(pit.x + 20 + i * 40, 552 + wave, 8, 6);
                }
                
                // Glow effect above lava
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#fc6000';
                ctx.fillRect(pit.x, 520, pit.width, 30);
                ctx.globalAlpha = 1;
            });
        }
        
        // Cave crystals (glowing!)
        const crystalTime = Date.now() / 200;
        for (let i = 0; i < 15; i++) {
            const x = cameraX + i * 200 + 50;
            const y = 100 + (i % 3) * 150;
            const glow = 0.5 + Math.sin(crystalTime + i) * 0.3;
            
            ctx.globalAlpha = glow;
            ctx.fillStyle = '#00fcfc';
            ctx.fillRect(x, y, 8, 16);
            ctx.fillRect(x + 2, y - 4, 4, 20);
            ctx.globalAlpha = 1;
        }
        
        // === –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø–æ—Ç–æ–ª–æ—á–Ω—ã—Ö —Ä–∞–∑—Ä—É—à–∞–µ–º—ã—Ö –ø–ª–∏—Ç–æ–∫ ===
        if (window.ceilingTiles) {
            window.ceilingTiles.forEach(tile => {
                if (tile.x < cameraX - 100 || tile.x > cameraX + canvas.width + 100) return;
                if (tile.broken) return;
                // –ë–∞–∑–æ–≤—ã–π –∫–∞–º–µ–Ω–Ω—ã–π –±–ª–æ–∫
                ctx.fillStyle = '#6b6b6b';
                ctx.fillRect(tile.x, tile.y, tile.width, tile.height);
                // –°–≤–µ—Ç–ª–∞—è –≥—Ä–∞–Ω—å
                ctx.fillStyle = '#8a8a8a';
                ctx.fillRect(tile.x + 2, tile.y + 2, tile.width - 4, tile.height - 6);
                // –¢—Ä–µ—â–∏–Ω—ã –æ—Ç —É—Ä–æ–Ω–∞
                const crack = tile.hits / tile.maxHits;
                ctx.fillStyle = '#3a3a3a';
                if (crack > 0) {
                    ctx.fillRect(tile.x + 4, tile.y + tile.height - 6, tile.width - 8, 2);
                }
                if (crack > 0.5) {
                    ctx.fillRect(tile.x + 8, tile.y + tile.height - 10, tile.width - 16, 2);
                }
            });
        }
    } else {
        // üé® PROFESSIONAL BACKGROUND RENDERING
        const levelConfig = LEVELS[level] || LEVELS[1];
        
        // Try to use real background sprite first
        if (backgroundSprites && backgroundSprites.complete && backgroundSprites.naturalWidth > 0) {
            // Render background sprite as a single large image with parallax
            const bgWidth = backgroundSprites.naturalWidth;
            const bgHeight = backgroundSprites.naturalHeight;
            
            // Calculate parallax offset
            const parallaxX = (cameraX * 0.1) % bgWidth;
            const parallaxY = (cameraX * 0.05) % bgHeight;
            
            // Render background sprite with proper tiling
            const startX = Math.floor(-parallaxX / bgWidth) * bgWidth - bgWidth;
            const startY = Math.floor(-parallaxY / bgHeight) * bgHeight - bgHeight;
            
            // Render multiple copies to fill the entire screen with extra coverage
            for (let x = startX; x < canvas.width + bgWidth * 4; x += bgWidth) {
                for (let y = startY; y < canvas.height + bgHeight * 4; y += bgHeight) {
                    ctx.drawImage(
                        backgroundSprites,
                        0, 0, bgWidth, bgHeight,
                        x, y, bgWidth, bgHeight
                    );
                }
            }
        } else {
            // Fallback to simple background
        ctx.fillStyle = levelConfig.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // PARALLAX LAYER 1 - Far mountains (slowest)
        ctx.fillStyle = 'rgba(100, 100, 150, 0.3)';
        const mountainOffset1 = cameraX * 0.1;
        for (let i = 0; i < 20; i++) {
            const x = i * 300 - mountainOffset1;
            if (x + 200 > cameraX && x < cameraX + canvas.width) {
                // Mountain peak
                ctx.fillRect(x + 50, 350, 100, 10);
                ctx.fillRect(x + 60, 340, 80, 10);
                ctx.fillRect(x + 70, 330, 60, 10);
                ctx.fillRect(x + 80, 320, 40, 10);
                ctx.fillRect(x + 90, 310, 20, 10);
            }
        }
        
        // PARALLAX LAYER 2 - Clouds (medium speed)
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.7;
        const cloudOffset = cameraX * 0.3;
        for (let i = 0; i < 25; i++) {
            const x = i * 250 - cloudOffset;
            const y = 50 + (i % 3) * 40;
            if (x + 80 > cameraX && x < cameraX + canvas.width) {
                ctx.fillRect(x, y, 60, 20);
                ctx.fillRect(x + 15, y - 10, 30, 10);
                ctx.fillRect(x + 40, y - 5, 25, 15);
            }
        }
        ctx.globalAlpha = 1;
        
        // PARALLAX LAYER 3 - Bushes/Hills (fast)
        ctx.fillStyle = '#2a7a2a';
        const bushOffset = cameraX * 0.6;
        for (let i = 0; i < 40; i++) {
            const x = i * 150 - bushOffset;
            if (x + 80 > cameraX && x < cameraX + canvas.width) {
                ctx.fillRect(x, 500, 80, 50);
                ctx.fillRect(x + 10, 490, 60, 10);
                ctx.fillRect(x + 20, 485, 40, 5);
            }
        }
    }
    
    // üé® PROFESSIONAL PLATFORM RENDERING
        platforms.forEach(p => {
        // –°–µ–∫—Ä–µ—Ç–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞ - –æ—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
        if (p.isSecretRoom && p.isBrick && player.x > 4100 && player.x < 4300) {
            console.log(`üß± SECRET ROOM BRICK: x=${p.x}, y=${p.y}, renderX=${p.x - cameraX}, cameraX=${cameraX}`);
        }
        
        // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–ª—è —Ä–∞–∑–±–∏–≤–∞—é—â–∏—Ö—Å—è –±–ª–æ–∫–æ–≤
        if (p.isBreakable && p.isSecretRoom && player.x > 4100 && player.x < 4300) {
            console.log(`üß± BREAKABLE BLOCK: x=${p.x}, y=${p.y}, renderX=${p.x - cameraX}, cameraX=${cameraX}, visible=${(p.x - cameraX) >= -50 && (p.x - cameraX) <= canvas.width + 50}`);
        }
        
        // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–ª—è —Ç–µ—Å—Ç–æ–≤—ã—Ö –±–ª–æ–∫–æ–≤ (–≤ –Ω–∞—á–∞–ª–µ —É—Ä–æ–≤–Ω—è)
        if (p.isSecretRoom && (p.x === 500 || p.x === 600)) {
            console.log(`üß™ TEST BLOCK: x=${p.x}, y=${p.y}, renderX=${p.x - cameraX}, cameraX=${cameraX}, isBreakable=${p.isBreakable}, isBrick=${p.isBrick}`);
        }
        // Determine biome based on level and position
        let biome = 'forest';
        if (inUnderground === 'contra') {
            biome = 'industrial';
        } else if (level > 3) {
            biome = 'autumn';
        } else if (level > 6) {
            biome = 'winter';
        } else if (p.x > 2000) {
            biome = 'desert';
        }
        
        // Use professional sprite rendering
        if (p.isSecretRoom && p.isBrick) {
            // –°–µ–∫—Ä–µ—Ç–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞ - –±–∏—Ä—é–∑–æ–≤—ã–µ –∫–∏—Ä–ø–∏—á–∏ –∫–∞–∫ –≤ –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–º –ú–∞—Ä–∏–æ
            const renderX = p.x - cameraX;
            const renderY = p.y;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∏–¥–∏–º–æ—Å—Ç—å –∫–∏—Ä–ø–∏—á–∞
            if (renderX >= -50 && renderX <= canvas.width + 50) {
                // –ë–∏—Ä—é–∑–æ–≤—ã–µ –∫–∏—Ä–ø–∏—á–∏ –∫–∞–∫ –≤ –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–º –ú–∞—Ä–∏–æ
                ctx.fillStyle = '#40E0D0'; // –ë–∏—Ä—é–∑–æ–≤—ã–π —Ü–≤–µ—Ç
                ctx.fillRect(renderX, renderY, p.width, p.height);
                
                // –¢–µ–º–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞
                ctx.strokeStyle = '#20B2AA';
                ctx.lineWidth = 1;
                ctx.strokeRect(renderX, renderY, p.width, p.height);
                
                // –¢–µ–∫—Å—Ç—É—Ä–∞ –∫–∏—Ä–ø–∏—á–∞ - –Ω–µ–±–æ–ª—å—à–∏–µ –∫–≤–∞–¥—Ä–∞—Ç–∏–∫–∏
                ctx.fillStyle = '#48D1CC';
                ctx.fillRect(renderX + 2, renderY + 2, 8, 8);
                ctx.fillRect(renderX + 14, renderY + 2, 8, 8);
                ctx.fillRect(renderX + 2, renderY + 14, 8, 8);
                ctx.fillRect(renderX + 14, renderY + 14, 8, 8);
            }
        } else if (p.isBreakable && p.isSecretRoom) {
            // –†–∞–∑–±–∏–≤–∞—é—â–∏–µ—Å—è –±–ª–æ–∫–∏ –≤ —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–Ω–∞—Ç–µ
            const renderX = p.x - cameraX;
            const renderY = p.y;
            
            // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–ª—è —Ä–∞–∑–±–∏–≤–∞—é—â–∏—Ö—Å—è –±–ª–æ–∫–æ–≤
            if (player.x > 4100 && player.x < 4300) {
                console.log(`üß± RENDERING BREAKABLE BLOCK: x=${p.x}, y=${p.y}, renderX=${renderX}, cameraX=${cameraX}, visible=${renderX >= -50 && renderX <= canvas.width + 50}`);
            }
            
            if (renderX >= -50 && renderX <= canvas.width + 50) {
                if (!p.broken) {
                    // –û–±—ã—á–Ω—ã–π —Ä–∞–∑–±–∏–≤–∞—é—â–∏–π—Å—è –±–ª–æ–∫ - –∫–æ—Ä–∏—á–Ω–µ–≤—ã–π —Å —Ç–æ—á–∫–∞–º–∏
                    ctx.fillStyle = '#8B4513'; // –ö–æ—Ä–∏—á–Ω–µ–≤—ã–π —Ü–≤–µ—Ç
                    ctx.fillRect(renderX, renderY, p.width, p.height);
                    
                    // –°–≤–µ—Ç–ª–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
                    ctx.strokeStyle = '#D2691E';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(renderX, renderY, p.width, p.height);
                    
                    // –¢–æ—á–∫–∏ –Ω–∞ –±–ª–æ–∫–µ –∫–∞–∫ –≤ –ú–∞—Ä–∏–æ
                    ctx.fillStyle = '#F4A460';
                    ctx.fillRect(renderX + 4, renderY + 4, 4, 4);
                    ctx.fillRect(renderX + 12, renderY + 4, 4, 4);
                    ctx.fillRect(renderX + 20, renderY + 4, 4, 4);
                    ctx.fillRect(renderX + 4, renderY + 12, 4, 4);
                    ctx.fillRect(renderX + 12, renderY + 12, 4, 4);
                    ctx.fillRect(renderX + 20, renderY + 12, 4, 4);
                    ctx.fillRect(renderX + 4, renderY + 20, 4, 4);
                    ctx.fillRect(renderX + 12, renderY + 20, 4, 4);
                    ctx.fillRect(renderX + 20, renderY + 20, 4, 4);
                    
                    // –û—Ç–ª–∞–¥–æ—á–Ω—ã–π —Ç–µ–∫—Å—Ç –Ω–∞ –±–ª–æ–∫–µ
                    if (player.x > 4100 && player.x < 4300) {
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = '8px Arial';
                        ctx.fillText('BLOCK', renderX + 2, renderY + 10);
                    }
    } else {
                    // –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞–∑–±–∏–≤–∞–Ω–∏—è
                    if (p.breakAnimation > 0) {
                        ctx.fillStyle = '#FFD700'; // –ó–æ–ª–æ—Ç–æ–π —Ü–≤–µ—Ç –ø—Ä–∏ —Ä–∞–∑–±–∏–≤–∞–Ω–∏–∏
                        ctx.fillRect(renderX, renderY, p.width, p.height);
                        p.breakAnimation--;
                    }
                }
            }
        } else if (p.isSecretRoom) {
            // –°–µ–∫—Ä–µ—Ç–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞ - –æ–±—ã—á–Ω—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(p.x - cameraX, p.y, p.width, p.height);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(p.x - cameraX, p.y, p.width, p.height);
        } else if (p.isShaftWall) {
            // –°—Ç–µ–Ω–∞ —à–∞—Ö—Ç—ã
            ctx.fillStyle = '#2C2C2C';
            ctx.fillRect(p.x - cameraX, p.y, p.width, p.height);
        } else if (p.isUpperCorridor) {
            // –í–µ—Ä—Ö–Ω–∏–π –∫–æ—Ä–∏–¥–æ—Ä - –ø—Ä–æ—Å—Ç—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(p.x - cameraX, p.y, p.width, p.height);
        } else if (p.isInvisibleBlock) {
            // –ù–µ–≤–∏–¥–∏–º—ã–π –±–ª–æ–∫ - —Ä–µ–Ω–¥–µ—Ä–∏–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã—Ç
            if (p.revealed) {
                ctx.fillStyle = '#FFD700'; // –∑–æ–ª–æ—Ç–æ–π —Ü–≤–µ—Ç
                ctx.fillRect(p.x - cameraX, p.y, p.width, p.height);
                ctx.strokeStyle = '#FFA500';
                ctx.lineWidth = 2;
                ctx.strokeRect(p.x - cameraX, p.y, p.width, p.height);
                
                // –¢–µ–∫—Å—Ç "?"
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('?', p.x - cameraX + p.width/2, p.y + p.height/2 + 4);
            }
    } else {
            // –û–±—ã—á–Ω—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
            renderProfessionalPlatform(p, biome);
        }
    });
    
    // üå≥ DECORATIVE OBJECTS RENDERING
    if (!inUnderground) {
        // Add decorative objects on platforms - reduced frequency
        platforms.forEach(p => {
            if (p.x > cameraX - 100 && p.x < cameraX + canvas.width + 100) {
                // Use platform position to create consistent decorations
                const platformHash = Math.floor(p.x / 100) + Math.floor(p.y / 100);
                
                // Much less frequent decorations - only every 12th platform (even less)
                if ((platformHash % 12) === 0) {
                    const decorationX = p.x + 20 + (platformHash % 40);
                    const decorationY = p.y - 32;
                    
                    // Choose decoration type - balanced mix including bushes
                    const decorationTypes = ['bush', 'stone', 'mushroom', 'bush', 'stone', 'mushroom', 'bush', 'tree']; // Bushes back in
                    const decorationType = decorationTypes[platformHash % decorationTypes.length];
                    
                    renderDecoration(decorationX, decorationY, decorationType);
                    
                    // Add second decoration on larger platforms - very rare
                    if (p.width > 200 && (platformHash % 24) === 0) {
                        const decorationX2 = p.x + 60 + (platformHash % 30);
                        const decorationY2 = p.y - 32;
                        const decorationType2 = decorationTypes[(platformHash + 1) % decorationTypes.length];
                        renderDecoration(decorationX2, decorationY2, decorationType2);
                    }
                }
            }
        });
    }
    
    // Blocks with bounce effect!
    blocks.forEach(block => {
        if (!block.broken) {
            const yOffset = block.bouncing ? -block.bounceOffset : 0;
            
            // Block looks like part of platform - –ò–°–ü–†–ê–í–õ–ï–ù–û!
            // –ë–ª–æ–∫–∏ —Ä–µ–Ω–¥–µ—Ä—è—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ ctx.translate(-cameraX, 0), –ø–æ—ç—Ç–æ–º—É –ù–ï –≤—ã—á–∏—Ç–∞–µ–º cameraX!
            const blockX = block.x;
            const blockY = block.y + yOffset;
            
            // DEBUG removed
            
            ctx.fillStyle = '#fc8000';
            ctx.fillRect(blockX, blockY, block.width, block.height);
            ctx.fillStyle = '#fca040';
            ctx.fillRect(blockX + 2, blockY + 2, block.width - 4, block.height - 4);
            
            // Question mark if has coin
            if (block.hasCoin) {
                ctx.fillStyle = '#fcfc00';
                ctx.fillRect(blockX + 10, blockY + 8, 10, 3);
                ctx.fillRect(blockX + 13, blockY + 5, 4, 8);
                ctx.fillRect(blockX + 13, blockY + 18, 4, 4);
            }
        }
    });
    
    // === –ù–û–í–û–ï: –†–∞–∑–±–∏–≤–∞–µ–º—ã–µ —Å—Ç–µ–Ω—ã ===
    if (window.breakableWalls) {
        window.breakableWalls.forEach(wall => {
            if (!wall.broken) {
                // –°—Ç–µ–Ω–∞
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                
                // –¢—Ä–µ—â–∏–Ω—ã (–∑–∞–≤–∏—Å—è—Ç –æ—Ç –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏–π)
                const crackLevel = wall.hits / wall.maxHits;
                ctx.fillStyle = '#3a2010';
                if (crackLevel > 0.3) {
                    ctx.fillRect(wall.x + 10, wall.y + 20, 10, 3);
                    ctx.fillRect(wall.x + 5, wall.y + 40, 20, 2);
                }
                if (crackLevel > 0.6) {
                    ctx.fillRect(wall.x + 15, wall.y + 10, 8, 3);
                    ctx.fillRect(wall.x + 8, wall.y + 55, 15, 3);
                }
                
                // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–Ω–∞—Ç—ã
                if (wall.hasSecret) {
                    const time = Date.now() / 300;
                    ctx.fillStyle = '#fcfc00';
                    ctx.globalAlpha = 0.3 + Math.sin(time) * 0.2;
                    ctx.fillRect(wall.x + 12, wall.y + 35, 6, 10);
                    ctx.fillRect(wall.x + 9, wall.y + 38, 12, 4);
                    ctx.globalAlpha = 1;
                }
            }
        });
    }
    
    // === –í–ò–ó–£–ê–õ–¨–ù–´–ô –ú–ê–†–ö–ï–† –°–ï–ö–†–ï–¢–ù–û–ô –ö–û–ú–ù–ê–¢–´ ===
    if (inUnderground && window.secretRoomMarker) {
        const marker = window.secretRoomMarker;
        const renderX = marker.x - cameraX;
        const renderY = marker.y;
        
        if (renderX >= -100 && renderX <= canvas.width + 100) {
            // –Ø—Ä–∫–∏–π –∫—Ä–∞—Å–Ω—ã–π –º–∞—Ä–∫–µ—Ä
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(renderX, renderY, marker.width, marker.height);
            
            // –ë–µ–ª—ã–π —Ç–µ–∫—Å—Ç
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SECRET ROOM', renderX + marker.width/2, renderY + 20);
            ctx.textAlign = 'left';
        }
    }
    
    // === –°–µ–∫—Ä–µ—Ç–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞: —Ä–µ–Ω–¥–µ—Ä —Ä—ã—á–∞–≥–∞ –∏ —Å—É–Ω–¥—É–∫–∞ ===
    if (inUnderground && window.secretTreasureRoom && window.secretTreasureRoom.revealed) {
        // –†—ã—á–∞–≥
        if (window.secretTreasureRoom.lever) {
            ctx.fillStyle = window.secretTreasureRoom.lever.activated ? '#fcfc00' : '#8b4513';
            ctx.fillRect(window.secretTreasureRoom.lever.x, window.secretTreasureRoom.lever.y, window.secretTreasureRoom.lever.width, window.secretTreasureRoom.lever.height);
            
            // –†—É—á–∫–∞ —Ä—ã—á–∞–≥–∞
            ctx.fillStyle = '#654321';
            ctx.fillRect(window.secretTreasureRoom.lever.x + 2, window.secretTreasureRoom.lever.y + 4, 12, 4);
            
            // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
            if (window.secretTreasureRoom.lever.activated) {
                const time = Date.now() / 200;
                ctx.fillStyle = '#fcfc00';
                ctx.globalAlpha = 0.5 + Math.sin(time) * 0.3;
                ctx.fillRect(window.secretTreasureRoom.lever.x - 2, window.secretTreasureRoom.lever.y - 2, 
                           window.secretTreasureRoom.lever.width + 4, window.secretTreasureRoom.lever.height + 4);
                ctx.globalAlpha = 1;
            }
        }
        
        // –°—É–Ω–¥—É–∫
        if (window.secretTreasureRoom.chest) {
            if (!window.secretTreasureRoom.chest.opened) {
                // –ó–∞–∫—Ä—ã—Ç—ã–π —Å—É–Ω–¥—É–∫
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(window.secretTreasureRoom.chest.x, window.secretTreasureRoom.chest.y, window.secretTreasureRoom.chest.width, window.secretTreasureRoom.chest.height);
                
                // –ú–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏
                ctx.fillStyle = '#c0c0c0';
                ctx.fillRect(window.secretTreasureRoom.chest.x + 4, window.secretTreasureRoom.chest.y + 2, 24, 4);
                ctx.fillRect(window.secretTreasureRoom.chest.x + 4, window.secretTreasureRoom.chest.y + 18, 24, 4);
                
                // –ó–∞–º–æ–∫
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(window.secretTreasureRoom.chest.x + 12, window.secretTreasureRoom.chest.y + 8, 8, 8);
                
                // –°–≤–µ—á–µ–Ω–∏–µ –µ—Å–ª–∏ —Ä—ã—á–∞–≥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω
                if (window.secretTreasureRoom.lever && window.secretTreasureRoom.lever.activated) {
                    const time = Date.now() / 300;
                    ctx.fillStyle = '#fcfc00';
                    ctx.globalAlpha = 0.3 + Math.sin(time) * 0.2;
                    ctx.fillRect(window.secretTreasureRoom.chest.x - 4, window.secretTreasureRoom.chest.y - 4, 
                               window.secretTreasureRoom.chest.width + 8, window.secretTreasureRoom.chest.height + 8);
                    ctx.globalAlpha = 1;
                }
            } else {
                // –û—Ç–∫—Ä—ã—Ç—ã–π —Å—É–Ω–¥—É–∫
                ctx.fillStyle = '#654321';
                ctx.fillRect(window.secretTreasureRoom.chest.x, window.secretTreasureRoom.chest.y, window.secretTreasureRoom.chest.width, window.secretTreasureRoom.chest.height);
                
                // –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —Å–≤–µ—á–µ–Ω–∏–µ
                ctx.fillStyle = '#fcfc00';
                ctx.globalAlpha = 0.6;
                ctx.fillRect(window.secretTreasureRoom.chest.x + 4, window.secretTreasureRoom.chest.y + 4, 
                           window.secretTreasureRoom.chest.width - 8, window.secretTreasureRoom.chest.height - 8);
                ctx.globalAlpha = 1;
            }
        }
    }
    
    // === –ù–û–í–û–ï: –§–∞–∫–µ–ª—ã (–≤ –ø–µ—â–µ—Ä–µ) ===
    if (window.torches && inUnderground) {
        window.torches.forEach(torch => {
            if (torch.x < cameraX - 100 || torch.x > cameraX + canvas.width + 100) return;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ä—Ü–∞–Ω–∏–µ - –µ—â–µ –±–æ–ª–µ–µ —É–º–µ–Ω—å—à–µ–Ω–Ω–∞—è —è—Ä–∫–æ—Å—Ç—å
            torch.flicker = Math.sin(Date.now() / 100 + torch.x * 0.01) * 0.15 + 0.4;
            
            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ —Ñ–∞–∫–µ–ª–∞
            ctx.fillStyle = '#4a2a1a';
            ctx.fillRect(torch.x - 3, torch.y, 6, 40);
            
            // –û–≥–æ–Ω—å - –Ω–∞–º–Ω–æ–≥–æ –º–µ–Ω–µ–µ —è—Ä–∫–∏–π
            const fireColors = ['#aa5000', '#aa2000', '#aaaa00'];  // Darker colors
            for (let i = 0; i < 3; i++) {
                ctx.fillStyle = fireColors[i];
                ctx.globalAlpha = (torch.flicker - i * 0.2) * 0.4;  // Reduced from 0.7 to 0.4
                const offset = (2 - i) * 2;
                ctx.fillRect(torch.x - 4 - offset, torch.y - 8 - i * 4, 8 + offset * 2, 8);
            }
            ctx.globalAlpha = 1;
        });
    }
    
    // === –ù–û–í–û–ï: –ì–æ—Ä—ã (–≤ —Ñ–æ–Ω–µ) ===
    if (!inUnderground) {
        platforms.forEach(p => {
            if (p.isMountain) {
                // –†–∏—Å—É–µ–º –ª–∏–Ω–∏—é –≥–æ—Ä—ã
                ctx.fillStyle = 'rgba(139, 69, 19, 0.3)';
                ctx.fillRect(p.x - 20, p.y + 20, 60, 2);
            }
            if (p.isSummit) {
                // –§–ª–∞–≥ –Ω–∞ –≤–µ—Ä—à–∏–Ω–µ!
                ctx.fillStyle = '#fcfc00';
                ctx.fillRect(p.x + p.width/2 - 2, p.y - 40, 4, 40);
                ctx.fillStyle = '#fc0000';
                ctx.fillRect(p.x + p.width/2 + 2, p.y - 35, 15, 10);
            }
        });
    }
    
    // Coins / Crystals
    coins.forEach(coin => {
        if (!coin.collected) {
            if (coin.isCrystal) {
                // Crystal with glow!
                const glow = 0.6 + Math.sin(Date.now() / 150 + coin.glowPhase) * 0.4;
                ctx.globalAlpha = glow;
                ctx.fillStyle = '#00fcfc';
                ctx.fillRect(coin.x + 8, coin.y, 8, 20);
                ctx.fillRect(coin.x + 4, coin.y + 6, 16, 8);
                ctx.fillStyle = '#fcfcfc';
                ctx.fillRect(coin.x + 10, coin.y + 4, 4, 12);
                ctx.globalAlpha = 1;
            } else {
                // Normal coin
                ctx.fillStyle = '#fcfc00';
                ctx.fillRect(coin.x + 4, coin.y, 16, 24);
                ctx.fillRect(coin.x, coin.y + 8, 24, 8);
            }
        }
    });
    
    // üóùÔ∏è KEYS RENDERING!
    gameKeys.forEach(key => {
        if (!key.collected) {
            const glow = 0.7 + Math.sin(key.glow) * 0.3;
            ctx.globalAlpha = glow;
            
            if (key.type === 'key1') {
                // Green key for underground
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(key.x + 8, key.y + 4, 8, 16); // Key shaft
                ctx.fillRect(key.x + 4, key.y + 8, 16, 8); // Key head
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(key.x + 6, key.y + 10, 4, 4); // Key hole
            } else if (key.type === 'key2') {
                // Red key for Contra
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(key.x + 8, key.y + 4, 8, 16); // Key shaft
                ctx.fillRect(key.x + 4, key.y + 8, 16, 8); // Key head
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(key.x + 6, key.y + 10, 4, 4); // Key hole
            }
            
            ctx.globalAlpha = 1;
        }
    });
    
    // ‚úÖ ANIMATED CHECKPOINTS!
    drawCheckpointsAnimated();
    
    // ‚úÖ ANIMATED POWER-UPS!
    drawPowerUpsAnimated();
    
    // üö™ PIPES WITH LOCKS!
    pipes.forEach(pipe => {
        const pipeColor = pipe.color || '#00fc00';
        const darkColor = pipe.isContra ? '#333' : '#00c000';
        
        // Special rendering for exit pipe (long vertical pipe like Mario)
        if (pipe.isExit && inUnderground) {
            // Long vertical pipe going up to the very top of screen
            const pipeHeight = pipe.y; // Go all the way to the top (y=0)
            const pipeTop = 0; // Start from the very top
            
            // Pipe body (vertical) - goes to the very top
            ctx.fillStyle = pipeColor;
            ctx.fillRect(pipe.x, pipeTop, pipe.width, pipeHeight);
            ctx.fillStyle = darkColor;
            ctx.fillRect(pipe.x + 5, pipeTop + 5, pipe.width - 10, pipeHeight - 10);
            
            // Pipe rim at top (at the very top of screen)
            ctx.fillStyle = pipeColor;
            ctx.fillRect(pipe.x - 5, pipeTop - 5, pipe.width + 10, 10);
            
            // Horizontal entrance at bottom (like Mario)
            ctx.fillStyle = pipeColor;
            ctx.fillRect(pipe.x - 10, pipe.y - 5, pipe.width + 20, 10);
            ctx.fillStyle = darkColor;
            ctx.fillRect(pipe.x - 5, pipe.y, pipe.width + 10, 5);
            
            // Arrow pointing up at the top
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px "Press Start 2P"';
            ctx.fillText('‚Üë', pipe.x + 20, pipeTop + 15);
            
            // "EXIT" text at bottom
            ctx.fillStyle = '#ffffff';
            ctx.font = '8px "Press Start 2P"';
            ctx.fillText('EXIT', pipe.x - 10, pipe.y + 15);
        } else {
            // Normal pipe rendering
        // Pipe body
        ctx.fillStyle = pipeColor;
        ctx.fillRect(pipe.x, pipe.y, pipe.width, pipe.height);
        ctx.fillStyle = darkColor;
        ctx.fillRect(pipe.x + 5, pipe.y + 5, pipe.width - 10, pipe.height - 10);
        // Pipe rim
        ctx.fillStyle = pipeColor;
        ctx.fillRect(pipe.x - 5, pipe.y - 5, pipe.width + 10, 10);
        }
        
        // üîí LOCK INDICATOR!
        if (pipe.locked) {
            // Lock icon
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(pipe.x + 20, pipe.y + 10, 20, 15);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(pipe.x + 25, pipe.y + 15, 10, 5);
            ctx.fillStyle = '#000000';
            ctx.fillRect(pipe.x + 27, pipe.y + 17, 6, 3);
            
            // Lock text
            ctx.fillStyle = '#ff0000';
            ctx.font = '6px "Press Start 2P"';
            ctx.fillText('LOCKED', pipe.x + 5, pipe.y - 5);
        } else {
            // Unlocked - show destination
            if (pipe.isContra) {
                ctx.fillStyle = '#fc0000';
                const time = Date.now() / 200;
                ctx.fillRect(pipe.x + 15, pipe.y + 15 + Math.sin(time) * 3, 30, 8);
                ctx.fillStyle = '#fff';
                ctx.font = '8px "Press Start 2P"';
                ctx.fillText('C', pipe.x + 22, pipe.y + 22);
            } else if (pipe.isUnderground || pipe.isExit) {
                ctx.fillStyle = '#fcfc00';
                const time = Date.now() / 300;
                ctx.fillRect(pipe.x + 20, pipe.y + 20 + Math.sin(time) * 5, 20, 5);
            }
        }
        
        // Show hint if player is near
        if (checkCollision(player, pipe)) {
            ctx.fillStyle = '#fff';
            ctx.font = '12px "Press Start 2P"';
            ctx.fillText('‚Üì', pipe.x + 23, pipe.y - 10);
        }
    });
    
    // Stars
    stars.forEach(star => {
        if (!star.collected) {
            const time = Date.now() / 100;
            ctx.fillStyle = '#fcfc00';
            // Draw 8-bit star
            ctx.fillRect(star.x + 12, star.y, 4, 28);
            ctx.fillRect(star.x, star.y + 12, 28, 4);
            ctx.fillRect(star.x + 6, star.y + 6, 16, 16);
            // Glow effect
            ctx.globalAlpha = 0.3 + Math.sin(time) * 0.2;
            ctx.fillRect(star.x - 4, star.y - 4, 36, 36);
            ctx.globalAlpha = 1;
        }
    });
    
     // Player - CAT SPRITE FOR ALL MODES
     // Player - CAT SPRITE üê±
     if (!spriteImg || !spriteImg.complete) {
         // Fallback if sprite not loaded yet - draw simple placeholder
         ctx.fillStyle = player.invincible ? '#fcfc00' : '#ffaacc';
         ctx.fillRect(player.x, player.y, player.width, player.height);
     } else {
        // Cat sprite sheet layout:
        // Row 0: idle (4 frames)
        // Row 1: walk (8 frames)
        // Row 2: jump (4 frames)
        // Row 3: fall (2 frames)
        // Row 4: dash (2 frames)
        // Row 5: attack (3 frames)
        
         // Determine current animation state and frame
         let animState = 'idle';
         let frameIndex = 0;
         
         if (player.dashing) {
             // Dash animation
             animState = 'dash';
             frameIndex = Math.floor((Date.now() / 100) % 2);
         } else if (!player.onGround) {
             // In air - check if going up or down
             if (player.velY < 0) {
                 // Jumping up
                 animState = 'jump';
                 frameIndex = Math.floor((Date.now() / 80) % 4);
             } else {
                 // Falling down
                 animState = 'fall';
                 frameIndex = Math.floor((Date.now() / 100) % 2);
             }
         } else if (Math.abs(player.velX) > 0.5) {
             // Walking/running on ground
             animState = 'walk';
             frameIndex = Math.floor((Date.now() / 80) % 8);
         } else {
             // Standing still on ground
             animState = 'idle';
             frameIndex = 3; // –°—Ç–∞—Ç–∏—á–Ω—ã–π –∫–∞–¥—Ä –¥–ª—è –ø–æ–∫–æ—è (–∫–∞–∫ –≤—ã —Å–∫–∞–∑–∞–ª–∏ - –∫–∞–¥—Ä 4, –Ω–æ –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—è —Å 0)
         }
         
        // Map animation state to sprite sheet row - FINDING STATIC IDLE!
        const stateToRow = {
            'idle': 3,    // –ü–æ–∫–æ–π = —Å—Ç—Ä–æ–∫–∞ 3 (–ø–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —Å—Ç–∞—Ç–∏—á–Ω—ã–π)
            'walk': 0,    // –•–æ–¥—å–±–∞ = —Å—Ç—Ä–æ–∫–∞ 0 (–±—ã–ª–∞ –∞–Ω–∏–º–∞—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è)
            'jump': 1,    // –ü—Ä—ã–∂–æ–∫ = —Å—Ç—Ä–æ–∫–∞ 1
            'fall': 2,    // –°–ø—É—Å–∫ = —Å—Ç—Ä–æ–∫–∞ 2
            'dash': 4,
            'attack': 5
        };
        
        // Debug info removed - animation logic is working correctly
        
        const row = stateToRow[animState] || 0;
        const spriteWidth = 32;
        const spriteHeight = 32;
        const sourceX = frameIndex * spriteWidth;
        const sourceY = row * spriteHeight;
        
        // Apply invincibility effect
        if (player.invincible) {
            ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 100) * 0.4;
        }
        
         // Draw cat sprite with proper direction
         ctx.save();
         
         // Debug info removed - sprites should load properly now
         
         // Flip sprite if facing left
         if (player.direction === -1) {
             ctx.translate(player.x + player.width, player.y);
             ctx.scale(-1, 1);
             ctx.drawImage(
                 spriteImg,
                 sourceX, sourceY, spriteWidth, spriteHeight,
                 0, 0, player.width, player.height
             );
         } else {
             ctx.translate(player.x, player.y);
             ctx.drawImage(
                 spriteImg,
                 sourceX, sourceY, spriteWidth, spriteHeight,
                 0, 0, player.width, player.height
             );
         }
         
         ctx.restore();
        ctx.globalAlpha = 1;
        
        // Draw invincibility field effect
        if (player.invincible && Math.random() < 0.3) {
            ctx.strokeStyle = '#fcfc00';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
    }
    
    // üëæ PROFESSIONAL ENEMY RENDERING
    enemies.forEach(e => {
        if (e.alive) {
            // Determine enemy type
            let enemyType = 'bacteria';
            if (e.isContra) {
                enemyType = 'contra';
            } else if (e.isBoss) {
                enemyType = 'boss';
            }
            
            // Use professional sprite rendering
            renderProfessionalEnemy(e, enemyType);
        }
    });
    
    // ü¶á PROFESSIONAL BAT RENDERING
    if (window.bats) {
        window.bats.forEach(bat => {
            if (bat.alive) {
                // Use professional sprite rendering for bats
                renderProfessionalEnemy(bat, 'bat');
            }
        });
    }
    
    // TURRETS! (Contra mode)
    if (window.turrets) {
        window.turrets.forEach(turret => {
            if (turret.alive) {
                // Base (like red mushroom base)
                ctx.fillStyle = '#d0a080';
                ctx.fillRect(turret.x + 4, turret.y + 18, 16, 10);
                
                // Base texture
                ctx.fillStyle = '#b08060';
                ctx.fillRect(turret.x + 6, turret.y + 20, 12, 2);
                ctx.fillRect(turret.x + 6, turret.y + 24, 12, 2);
                
                // Mushroom cap (RED!)
                ctx.fillStyle = '#d02020';
                ctx.fillRect(turret.x + 2, turret.y + 8, 20, 10);
                ctx.fillRect(turret.x, turret.y + 12, 24, 6);
                
                // Mushroom spots (white)
                ctx.fillStyle = '#fff';
                ctx.fillRect(turret.x + 6, turret.y + 10, 4, 4);
                ctx.fillRect(turret.x + 14, turret.y + 10, 4, 4);
                ctx.fillRect(turret.x + 4, turret.y + 14, 3, 3);
                ctx.fillRect(turret.x + 17, turret.y + 14, 3, 3);
                
                // Cap highlight
                ctx.fillStyle = '#fc4040';
                ctx.fillRect(turret.x + 4, turret.y + 9, 16, 2);
                
                // Gun barrel (rotating towards player!)
                const angle = Math.atan2(player.y - turret.y, player.x - turret.x);
                const barrelLength = 10;
                const barrelX = turret.x + 12 + Math.cos(angle) * barrelLength;
                const barrelY = turret.y + 14 + Math.sin(angle) * barrelLength;
                
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(turret.x + 10, turret.y + 13, 4, 4);
                
                // Barrel pointing at player
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(turret.x + 12, turret.y + 15);
                ctx.lineTo(barrelX, barrelY);
                ctx.stroke();
                
                // Health indicator
                if (turret.health < 3) {
                    ctx.fillStyle = turret.health === 2 ? '#fcfc00' : '#fc0000';
                    for (let i = 0; i < turret.health; i++) {
                        ctx.fillRect(turret.x + 6 + i * 4, turret.y - 4, 3, 2);
                    }
                }
            }
        });
    }
    
    // Enemy bullets
    if (window.enemyBullets) {
        window.enemyBullets.forEach(bullet => {
            // Red enemy bullet
            ctx.fillStyle = '#fc0000';
            ctx.fillRect(bullet.x - 1, bullet.y - 1, bullet.width + 2, bullet.height + 2);
            ctx.fillStyle = '#fc8000';
            ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            ctx.fillStyle = '#fcfc00';
            ctx.fillRect(bullet.x + 1, bullet.y + 1, bullet.width - 2, bullet.height - 2);
        });
    }
    
    // Boss projectiles - IMPROVED VISIBILITY!
    if (window.bossProjectiles) {
        window.bossProjectiles.forEach(proj => {
            // Outer glow
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(proj.x - 3, proj.y - 3, proj.width + 6, proj.height + 6);
            
            // Main projectile
            ctx.fillStyle = '#ff8000';
            ctx.fillRect(proj.x - 1, proj.y - 1, proj.width + 2, proj.height + 2);
            
            // Inner core
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(proj.x, proj.y, proj.width, proj.height);
            
            // Center dot
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(proj.x + 2, proj.y + 2, proj.width - 4, proj.height - 4);
        });
    }
    
    // Falling rocks!
    if (window.fallingRocks) {
        window.fallingRocks.forEach(rock => {
            if (rock.y > 0 && rock.y < 600) {
                // Rock
                ctx.fillStyle = '#5a5a5a';
                ctx.fillRect(rock.x, rock.y, rock.width, rock.height);
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(rock.x + 2, rock.y + 2, rock.width - 4, rock.height - 4);
                ctx.fillStyle = '#3a3a3a';
                ctx.fillRect(rock.x + 4, rock.y + 4, rock.width - 8, rock.height - 8);
                
                // Warning indicator if about to fall
                if (!rock.falling && Math.abs(player.x - rock.x) < 80) {
                    ctx.fillStyle = '#fc0000';
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.3;
                    ctx.fillRect(rock.x + 8, 10, 8, 20);
                    ctx.globalAlpha = 1;
                }
            }
        });
    }
    
    // Bullets (Contra mode!)
    if (player.bullets) {
        player.bullets.forEach(bullet => {
            if (bullet.type === 'fireball') {
                // FIREBALL - EPIC EXPLOSIVE! üî•
                // Outer glow
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(bullet.x - 4, bullet.y - 4, bullet.width + 8, bullet.height + 8);
                
                // Main fireball
                ctx.fillStyle = '#ff4500';
                ctx.fillRect(bullet.x - 2, bullet.y - 2, bullet.width + 4, bullet.height + 4);
                
                // Inner core
                ctx.fillStyle = '#ffa500';
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                
                // Center flame
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(bullet.x + 2, bullet.y + 2, bullet.width - 4, bullet.height - 4);
                
                // White hot center
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(bullet.x + 4, bullet.y + 4, bullet.width - 8, bullet.height - 8);
                
            } else if (bullet.type === 'laser') {
                // Laser beam - bright cyan
                ctx.fillStyle = '#00fcfc';
                ctx.fillRect(bullet.x, bullet.y - 1, bullet.width, bullet.height + 2);
                ctx.fillStyle = '#fcfcfc';
                ctx.fillRect(bullet.x + 2, bullet.y, bullet.width - 4, bullet.height);
            } else if (bullet.type === 'spread') {
                // Spread bullets - orange
                ctx.fillStyle = '#fc8000';
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                ctx.fillStyle = '#fcfc00';
                ctx.fillRect(bullet.x + 1, bullet.y, bullet.width - 2, bullet.height);
            } else {
                // Normal bullets - yellow
                ctx.fillStyle = '#fcfc00';
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                ctx.fillStyle = '#fc8000';
                ctx.fillRect(bullet.x + 2, bullet.y, bullet.width - 4, bullet.height);
            }
        });
    }
    
    // Goal flag
    // üï≥Ô∏è BLACK HOLE RENDERING
    if (blackHole && blackHole.isActive) {
        ctx.save();
        
        // Draw swirling particles
        blackHole.particles.forEach(particle => {
            ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.random() * 0.4})`;
            ctx.fillRect(particle.x, particle.y, 2, 2);
        });
        
        // Draw black hole center (rotating)
        ctx.translate(blackHole.x + 50, blackHole.y + 50);
        ctx.rotate(blackHole.rotation);
        
        // Outer ring (dark purple)
        ctx.fillStyle = '#400040';
        ctx.beginPath();
        ctx.arc(0, 0, blackHole.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Middle ring (darker)
        ctx.fillStyle = '#200020';
        ctx.beginPath();
        ctx.arc(0, 0, blackHole.radius * 0.7, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner core (pure black)
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(0, 0, blackHole.radius * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Event horizon (white ring)
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, blackHole.radius * 0.4, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.restore();
        
        // üï≥Ô∏è BLACK HOLE MESSAGE RENDERING
        if (blackHole.messageTimer > 0) {
            ctx.save();
            ctx.translate(cameraX, 0); // Reset camera offset for UI
            
            // Dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Message text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            
            let message = '';
            let subMessage = '';
            
            if (blackHole.messagePhase === 0) {
                message = 'üï≥Ô∏è BLACK HOLE!';
                subMessage = 'You have been consumed by the void!';
            } else if (blackHole.messagePhase === 1) {
                message = 'üåå SPACE TRANSITION! üåå';
                subMessage = 'Entering the cosmic arena...';
            } else if (blackHole.messagePhase === 2) {
                message = 'Prepare for battle!';
                subMessage = 'The final boss awaits in space!';
            }
            
            // Main message
            ctx.fillStyle = '#fcfc00';
            ctx.font = 'bold 32px Arial';
            ctx.fillText(message, canvas.width / 2, canvas.height / 2 - 40);
            
            // Sub message
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.fillText(subMessage, canvas.width / 2, canvas.height / 2 + 20);
            
            // Additional text for phase 0
            if (blackHole.messagePhase === 0) {
                ctx.fillStyle = '#cccccc';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('The cosmic arena awaits...', canvas.width / 2, canvas.height / 2 + 60);
            }
            
            ctx.restore();
        }
    }
    
    // Legacy goal rendering (if no black hole)
    if (goal && !blackHole) {
        ctx.fillStyle = '#fcfc00';
        ctx.fillRect(goal.x, goal.y, 8, goal.height);
        ctx.fillStyle = '#fc0000';
        ctx.fillRect(goal.x + 8, goal.y, 30, 40);
    }
    
    // Particles
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 4, 4);
    });
    
    // ‚úÖ BOSS RENDERING!
    drawBoss();
    
    // COMBO DISPLAY!
    if (combo > 1) {
        ctx.save();
        ctx.translate(cameraX, 0);
        
        const comboX = player.x;
        const comboY = player.y - 40;
        
        // Combo background
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = '#000';
        ctx.fillRect(comboX - 5, comboY - 20, 70, 30);
        ctx.globalAlpha = 1;
        
        // Combo text with color based on combo level
        let comboColor = '#fcfc00'; // Yellow
        if (combo >= 10) comboColor = '#fc00fc'; // Purple - MEGA!
        else if (combo >= 5) comboColor = '#fc8000'; // Orange - SUPER!
        
        ctx.fillStyle = comboColor;
        ctx.font = '14px "Press Start 2P"';
        ctx.fillText(`x${combo}`, comboX, comboY);
        
        // Combo label
        ctx.font = '8px "Press Start 2P"';
        ctx.fillText('COMBO', comboX, comboY + 10);
        
        // Flash effect when combo timer is low
        if (comboTimer < 30 && Math.floor(Date.now() / 100) % 2 === 0) {
            ctx.fillStyle = '#fc0000';
            ctx.fillText('!', comboX + 55, comboY);
        }
        
        ctx.restore();
    }
    
    // ‚úÖ CAVE LIGHTING EFFECT!
    drawCaveLighting();
    
    // üî• DOOM DOOR RENDERING
    renderDoomDoor();
    
    ctx.restore();
    
    // ‚úÖ POWER-UP STATUS INDICATORS! - MOVED AFTER ctx.restore() FOR FIXED SCREEN POSITION!
    drawPowerUpStatus();
}

// Draw boss (if present)
function drawBoss() {
    if (!currentBoss || !currentBoss.alive) return;
    
    const boss = currentBoss;
    
    // üêõ DEBUG - –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–∑–∏—Ü–∏—é –±–æ—Å—Å–∞
    const screenX = boss.x - cameraX;
    const onScreen = (screenX > -100 && screenX < canvas.width + 100);
    
    if (Math.random() < 0.01) { // –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–¥–∫–æ
        console.log('üëæ BOSS:', 
            'alive:', boss.alive, 
            'x:', Math.floor(boss.x), 
            'y:', Math.floor(boss.y),
            'camera:', Math.floor(cameraX),
            'onScreen:', onScreen,
            'screenX:', Math.floor(screenX),
            'bossActive:', bossActive
        );
    }
    
    // ‚úÖ –†–ò–°–£–ï–ú –ë–û–°–°–ê –í–°–ï–ì–î–ê –ï–°–õ–ò –û–ù ALIVE!
    // –ù–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º onScreen —á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å –±–æ—Å—Å–∞ –≤—Å–µ–≥–¥–∞
    
    // üìä BOSS HEALTH BAR - –≤—Å–µ–≥–¥–∞ –≤–∏–¥–µ–Ω –∫–æ–≥–¥–∞ –±–æ—Å—Å –∞–∫—Ç–∏–≤–µ–Ω
    if (bossActive) {
        ctx.save();
        
        // Health bar –ø—Ä–∏–≤—è–∑–∞–Ω –∫ —ç–∫—Ä–∞–Ω—É (HUD), –Ω–µ –∫ –º–∏—Ä—É - IMPROVED!
        // Background
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(50, 30, 320, 30);
        
        // Border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(50, 30, 320, 30);
        
        // Health bar with damage flash effect
        const healthPercent = boss.health / boss.maxHealth;
        let healthColor = '#ff0000'; // Red
        if (healthPercent > 0.6) healthColor = '#00ff00'; // Green
        else if (healthPercent > 0.3) healthColor = '#ffff00'; // Yellow
        
        // Flash effect when taking damage
        if (boss.damageFlash > 0) {
            healthColor = '#ffffff'; // White flash
        }
        
        ctx.fillStyle = healthColor;
        ctx.fillRect(52, 32, 316 * healthPercent, 26);
        
        // Boss name and health text - IMPROVED!
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('üëæ BOSS HEALTH', 60, 50);
        
        // Health percentage
        ctx.fillStyle = '#ffff00';
        ctx.font = 'bold 12px Arial';
        ctx.fillText(`${Math.ceil(boss.health)}/${boss.maxHealth} (${Math.round(healthPercent * 100)}%)`, 200, 50);
        
        ctx.restore();
    }
    
    // üëæ –†–ò–°–£–ï–ú –°–ü–†–ê–ô–¢ –ë–û–°–°–ê (—Å —É—á–µ—Ç–æ–º –∫–∞–º–µ—Ä—ã!)
    // –§–ª—ç—à —ç—Ñ—Ñ–µ–∫—Ç –ø—Ä–∏ —É—Ä–æ–Ω–µ
    if (boss.damageFlash > 0) {
        ctx.globalAlpha = 0.5 + (boss.damageFlash % 2) * 0.5;
    }
    
    // GIANT BACTERIA BOSS - –¥–µ—Ç–∞–ª—å–Ω—ã–π —Å–ø—Ä–∞–π—Ç (–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–∞–º–µ—Ä—ã)
    // –ë–æ—Å—Å —Ä–µ–Ω–¥–µ—Ä–∏—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ ctx.translate(-cameraX, 0), –ø–æ—ç—Ç–æ–º—É –ù–ï –≤—ã—á–∏—Ç–∞–µ–º cameraX!
    const bx = boss.x;
    const by = boss.y;
    
    // DEBUG removed
    const pulse = Math.sin(boss.animFrame) * 5;
    
    // –û—Å–Ω–æ–≤–Ω–æ–µ —Ç–µ–ª–æ
    ctx.fillStyle = '#00fc00';
    ctx.fillRect(bx + 10, by + 10 + pulse, 60, 60);
    ctx.fillRect(bx + 5, by + 20 + pulse, 70, 40);
    
    // –ì–ª–∞–∑–∞
    ctx.fillStyle = '#fc0000';
    ctx.fillRect(bx + 20, by + 25 + pulse, 12, 12);
    ctx.fillRect(bx + 48, by + 25 + pulse, 12, 12);
    
    // –ó—Ä–∞—á–∫–∏
    ctx.fillStyle = '#000';
    ctx.fillRect(bx + 24, by + 29 + pulse, 4, 4);
    ctx.fillRect(bx + 52, by + 29 + pulse, 4, 4);
    
    // –†–æ—Ç
    ctx.fillStyle = '#000';
    ctx.fillRect(bx + 30, by + 48 + pulse, 20, 4);
    ctx.fillRect(bx + 28, by + 50 + pulse, 24, 3);
    
    // –©—É–ø–∞–ª—å—Ü–∞ (–∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ)
    for (let i = 0; i < 6; i++) {
        const angle = (boss.animFrame * 0.5 + i) * Math.PI / 3;
        const tx = bx + 40 + Math.cos(angle) * 40;
        const ty = by + 40 + Math.sin(angle) * 40;
        
        ctx.fillStyle = '#00fc00';
        ctx.fillRect(tx, ty, 8, 16);
        ctx.fillStyle = '#00c000';
        ctx.fillRect(tx + 2, ty + 4, 4, 8);
    }
    
    ctx.globalAlpha = 1;
    
    // üí• DEBUG: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º hitbox (—Å —É—á–µ—Ç–æ–º –∫–∞–º–µ—Ä—ã!)
    // Debug hitbox removed for better gameplay
}

// Draw checkpoints with animation
function drawCheckpointsAnimated() {
    checkpoints.forEach(cp => {
        if (cp.x < cameraX - 100 || cp.x > cameraX + canvas.width + 100) return;
        
        const flagHeight = cp.activated ? 40 : 20;
        const time = Date.now() / 1000;
        const wave = Math.sin(time * 3 + cp.x * 0.01) * 5;
        
        // Flag pole
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(cp.x, cp.y - flagHeight, 5, flagHeight);
        
        // Flag
        ctx.fillStyle = cp.activated ? '#00ff00' : '#ffaa00';
        ctx.beginPath();
        ctx.moveTo(cp.x + 5, cp.y - flagHeight);
        ctx.lineTo(cp.x + 35, cp.y - flagHeight + 10 + wave);
        ctx.lineTo(cp.x + 5, cp.y - flagHeight + 20);
        ctx.fill();
        
        // Glow effect if activated
        if (cp.activated) {
            ctx.save();
            ctx.globalAlpha = 0.3 + Math.sin(time * 5) * 0.2;
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(cp.x + 20, cp.y - 20, 30, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    });
}

// Draw power-ups with fancy graphics
function drawPowerUpsAnimated() {
    powerUps.forEach(pu => {
        if (pu.collected || pu.x < cameraX - 100 || pu.x > cameraX + canvas.width + 100) return;
        
        const time = Date.now() / 1000;
        const bounce = Math.sin(time * 4 + pu.x * 0.05) * 5;
        const pulse = 1 + Math.sin(time * 6) * 0.1;
        
        ctx.save();
        ctx.translate(pu.x + pu.width/2, pu.y + bounce + pu.height/2);
        ctx.scale(pulse, pulse);
        ctx.translate(-(pu.x + pu.width/2), -(pu.y + bounce + pu.height/2));
        
        // Different visuals per type
        switch(pu.type) {
            case 'shield':
                // Shield icon
                ctx.fillStyle = '#4169E1';
                ctx.beginPath();
                ctx.moveTo(pu.x + pu.width/2, pu.y + bounce);
                ctx.lineTo(pu.x, pu.y + bounce + pu.height/3);
                ctx.lineTo(pu.x, pu.y + bounce + pu.height);
                ctx.lineTo(pu.x + pu.width, pu.y + bounce + pu.height);
                ctx.lineTo(pu.x + pu.width, pu.y + bounce + pu.height/3);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.stroke();
                break;
                
            case 'speedboots':
                // Lightning bolt
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.moveTo(pu.x + pu.width * 0.6, pu.y + bounce);
                ctx.lineTo(pu.x + pu.width * 0.3, pu.y + bounce + pu.height * 0.5);
                ctx.lineTo(pu.x + pu.width * 0.5, pu.y + bounce + pu.height * 0.5);
                ctx.lineTo(pu.x + pu.width * 0.2, pu.y + bounce + pu.height);
                ctx.lineTo(pu.x + pu.width * 0.5, pu.y + bounce + pu.height * 0.6);
                ctx.lineTo(pu.x + pu.width * 0.4, pu.y + bounce + pu.height * 0.6);
                ctx.closePath();
                ctx.fill();
                break;
            case 'MUSHROOM_ARTIFACT':
                // –ì—Ä–∏–±-–∞—Ä—Ç–µ—Ñ–∞–∫—Ç - –∫—Ä–∞—Å–Ω—ã–π –≥—Ä–∏–± —Å –∑–æ–ª–æ—Ç—ã–º –±–ª–µ—Å–∫–æ–º
                ctx.fillStyle = '#FF6B6B'; // –∫—Ä–∞—Å–Ω—ã–π –≥—Ä–∏–±
                ctx.fillRect(pu.x, pu.y + bounce, pu.width, pu.height);
                ctx.fillStyle = '#FFD700'; // –∑–æ–ª–æ—Ç–æ–π –±–ª–µ—Å–∫
                ctx.fillRect(pu.x + 2, pu.y + bounce + 2, pu.width - 4, 4);
                ctx.fillRect(pu.x + 2, pu.y + bounce + pu.height - 6, pu.width - 4, 4);
                
                // –ë–µ–ª—ã–µ —Ç–æ—á–∫–∏ –Ω–∞ –≥—Ä–∏–±–µ
                ctx.fillStyle = '#FFF';
                ctx.fillRect(pu.x + 6, pu.y + bounce + 6, 3, 3);
                ctx.fillRect(pu.x + 15, pu.y + bounce + 8, 3, 3);
                ctx.fillRect(pu.x + 8, pu.y + bounce + 12, 2, 2);
                break;
                
            case 'fireball':
                // Fireball
                ctx.fillStyle = '#FF4500';
                ctx.beginPath();
                ctx.arc(pu.x + pu.width/2, pu.y + bounce + pu.height/2, pu.width/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(pu.x + pu.width/2, pu.y + bounce + pu.height/2, pu.width/3, 0, Math.PI * 2);
                ctx.fill();
                break;
                
            case 'superjump':
                // Spring/boots
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(pu.x, pu.y + bounce + pu.height * 0.6, pu.width, pu.height * 0.4);
                ctx.fillStyle = '#228B22';
                for(let i = 0; i < 3; i++) {
                    ctx.fillRect(pu.x + 5, pu.y + bounce + i * 8, pu.width - 10, 6);
                }
                break;
        }
        
        // Outer glow
        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(pu.x - 2, pu.y + bounce - 2, pu.width + 4, pu.height + 4);
        
        ctx.restore();
    });
}

// Draw cave lighting effect
function drawCaveLighting() {
    if (!inUnderground || inUnderground === 'contra') return; // Only in cave
    
    ctx.save();
    
    // MUCH lighter overlay for better visibility
    ctx.fillStyle = 'rgba(0, 0, 20, 0.2)';  // Reduced from 0.4 to 0.2
    ctx.fillRect(cameraX, 0, canvas.width, canvas.height);
    
    // Light around player - much reduced brightness
    const gradient = ctx.createRadialGradient(
        player.x - cameraX + player.width/2, 
        player.y + player.height/2, 
        20,
        player.x - cameraX + player.width/2, 
        player.y + player.height/2, 
        180
    );
    gradient.addColorStop(0, 'rgba(255, 220, 150, 0.3)');  // Reduced from 0.6 to 0.3
    gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.1)'); // Reduced from 0.2 to 0.1
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    
    ctx.globalCompositeOperation = 'destination-out';
    ctx.fillStyle = gradient;
    ctx.fillRect(cameraX, 0, canvas.width, canvas.height);
    
    // Torch lights
    if (window.torches) {
        window.torches.forEach(torch => {
            if (torch.x < cameraX - 200 || torch.x > cameraX + canvas.width + 200) return;
            
            const torchGradient = ctx.createRadialGradient(
                torch.x, torch.y, 5,
                torch.x, torch.y, 80
            );
            const flicker = 0.4 + Math.random() * 0.2;
            torchGradient.addColorStop(0, `rgba(255, 150, 50, ${flicker})`);
            torchGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = torchGradient;
            ctx.fillRect(cameraX, 0, canvas.width, canvas.height);
        });
    }
    
    ctx.restore();
}

// Power-up status indicators
function drawPowerUpStatus() {
    let yOffset = 100;
    
    // üóùÔ∏è KEYS INVENTORY!
    if (playerProgress.hasKey1 || playerProgress.hasKey2) {
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(10, yOffset, 200, 30);
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px "Press Start 2P"';
        ctx.fillText('KEYS:', 15, yOffset + 12);
        
        if (playerProgress.hasKey1) {
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(80, yOffset + 5, 16, 20);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(84, yOffset + 9, 8, 4);
            ctx.fillStyle = '#000000';
            ctx.fillRect(86, yOffset + 11, 4, 2);
        }
        
        if (playerProgress.hasKey2) {
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(110, yOffset + 5, 16, 20);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(114, yOffset + 9, 8, 4);
            ctx.fillStyle = '#000000';
            ctx.fillRect(116, yOffset + 11, 4, 2);
        }
        
        ctx.restore();
        yOffset += 40;
    }
    
    if (player.hasShield) {
        ctx.save();
        const pulse = 1 + Math.sin(Date.now() / 200) * 0.1;
        ctx.globalAlpha = 0.7;
        ctx.strokeStyle = '#4169E1';
        ctx.lineWidth = 3 * pulse;
        ctx.strokeRect(
            player.x - cameraX - 5, 
            player.y - 5, 
            player.width + 10, 
            player.height + 10
        );
        ctx.restore();
        
        // Shield timer UI - IMPROVED!
        ctx.fillStyle = 'rgba(65, 105, 225, 0.9)';
        ctx.fillRect(10, yOffset, 120, 25);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        const shieldTime = Math.ceil(player.shieldTimer / 60);
        ctx.fillText(`üõ°Ô∏è SHIELD: ${shieldTime}s`, 15, yOffset + 17);
        yOffset += 30;
    }
    
    if (player.hasSpeedBoots) {
        // Speed lines behind player
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
        ctx.lineWidth = 2;
        for(let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(player.x - cameraX - 10 - i * 5, player.y + 10 + i * 5);
            ctx.lineTo(player.x - cameraX - 20 - i * 5, player.y + 10 + i * 5);
            ctx.stroke();
        }
        
        // Speed timer UI - IMPROVED!
        ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
        ctx.fillRect(10, yOffset, 120, 25);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        const speedTime = Math.ceil(player.speedBootsTimer / 60);
        ctx.fillText(`‚ö° SPEED: ${speedTime}s`, 15, yOffset + 17);
        yOffset += 30;
    }
    
    if (player.hasFireball) {
        // Fireball UI - IMPROVED!
        ctx.fillStyle = 'rgba(255, 69, 0, 0.9)';
        ctx.fillRect(10, yOffset, 120, 25);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        const fireballTime = Math.ceil(player.fireballTimer / 60);
        ctx.fillText(`üî• FIREBALL: ${fireballTime}s`, 15, yOffset + 17);
        yOffset += 30;
    }
    
    if (player.hasSuperJump) {
        // Super Jump UI - IMPROVED!
        ctx.fillStyle = 'rgba(138, 43, 226, 0.9)';
        ctx.fillRect(10, yOffset, 120, 25);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        const superJumpTime = Math.ceil(player.superJumpTimer / 60);
        ctx.fillText(`üöÄ SUPER JUMP: ${superJumpTime}s`, 15, yOffset + 17);
        yOffset += 30;
    }
}

function checkCollision(a, b) {
    return a.x < b.x + (b.width || 24) &&
           a.x + a.width > b.x &&
           a.y < b.y + (b.height || 24) &&
           a.y + a.height > b.y;
}

function createParticles(x, y, color, count = 8) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x, y,
            velX: (Math.random() - 0.5) * 6,
            velY: (Math.random() - 0.5) * 6 - 2, // Slight upward bias
            color, life: 30
        });
    }
}

function gameOver() {
    gameRunning = false;
    stopBackgroundMusic();
    document.getElementById('finalScore').textContent = score;
    document.getElementById('gameOverScreen').style.display = 'block';
    playSound('gameover');
}

function victory() {
    gameRunning = false;
    stopBackgroundMusic();
    score += 1000;
    
    // üéÆ PROGRESS TRACKING!
    if (inUnderground === 'contra') {
        playerProgress.contraCleared = true;
        console.log('üéØ CONTRA LEVEL CLEARED!');
    } else if (inUnderground) {
        playerProgress.undergroundCleared = true;
        console.log('üéØ UNDERGROUND LEVEL CLEARED!');
    } else if ((goal && goal.isFinalExit) || (blackHole && blackHole.isFinalExit)) {
        // üèÅ FINAL EXIT REACHED!
        console.log('üèÅ FINAL EXIT REACHED! GAME COMPLETED!');
        alert('üéâ CONGRATULATIONS! üéâ\nYou have completed the entire game!\nAll areas cleared!\nFinal Score: ' + score);
    }
    
    document.getElementById('victoryScore').textContent = score;
    document.getElementById('victoryScreen').style.display = 'block';
    playSound('victory');
}

// –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∑–≤—É–∫–æ–≤
let activeSounds = 0;
const MAX_SOUNDS = 3;

function playSound(type) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∫–ª—é—á–µ–Ω –ª–∏ –∑–≤—É–∫
    if (!soundEnabled) return;
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∑–≤—É–∫–æ–≤
    if (activeSounds >= MAX_SOUNDS) return;
    
    activeSounds++;
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    
    const sounds = {
        jump: [500, 0.1],
        coin: [800, 0.15],
        hit: [100, 0.2],
        stomp: [600, 0.1],
        break: [400, 0.15],
        powerup: [1000, 0.3],
        victory: [1200, 0.5],
        gameover: [200, 0.8],
        warp: [300, 0.4],
        star: [1500, 0.6],
        doublejump: [700, 0.12],
        shoot: [1200, 0.08],
        explosion: [150, 0.15],
        land: [250, 0.08],
        dash: [900, 0.12] // Dash sound
    };
    
    const [freq, dur] = sounds[type] || [440, 0.1];
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.2, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + dur);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + dur);
    
    // –°–±—Ä–æ—Å —Å—á–µ—Ç—á–∏–∫–∞ –∑–≤—É–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    setTimeout(() => {
        activeSounds = Math.max(0, activeSounds - 1);
    }, dur * 1000);
}

// Underground music (simple looping melody)
function startUndergroundMusic() {
    stopBackgroundMusic();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∫–ª—é—á–µ–Ω –ª–∏ –∑–≤—É–∫
    if (!soundEnabled) return;
    
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const notes = [196, 220, 246, 220, 196, 174, 196, 220]; // Underground melody
    let noteIndex = 0;
    
    function playNote() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∫–ª—é—á–µ–Ω –ª–∏ –∑–≤—É–∫ –ø–µ—Ä–µ–¥ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ–º –Ω–æ—Ç—ã
        if (!soundEnabled) return;
        
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.type = 'square'; // 8-bit sound
        osc.frequency.value = notes[noteIndex];
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.3);
        
        noteIndex = (noteIndex + 1) % notes.length;
    }
    
    playNote();
    bgMusicInterval = setInterval(() => {
        if (!soundEnabled) {
            clearInterval(bgMusicInterval);
            bgMusicInterval = null;
            return;
        }
        playNote();
    }, 400);
}

function stopBackgroundMusic() {
    if (bgMusicInterval) {
        clearInterval(bgMusicInterval);
        bgMusicInterval = null;
    }
}

// Contra music (intense military theme!)
function startContraMusic() {
    stopBackgroundMusic();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∫–ª—é—á–µ–Ω –ª–∏ –∑–≤—É–∫
    if (!soundEnabled) return;
    
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // Contra-style aggressive melody
    const notes = [330, 349, 392, 440, 392, 349, 330, 294, 330, 349]; 
    let noteIndex = 0;
    
    function playNote() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∫–ª—é—á–µ–Ω –ª–∏ –∑–≤—É–∫ –ø–µ—Ä–µ–¥ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ–º –Ω–æ—Ç—ã
        if (!soundEnabled) return;
        
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.type = 'sawtooth'; // Aggressive sound!
        osc.frequency.value = notes[noteIndex];
        gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
        
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.2);
        
        noteIndex = (noteIndex + 1) % notes.length;
    }
    
    playNote();
    bgMusicInterval = setInterval(() => {
        if (!soundEnabled) {
            clearInterval(bgMusicInterval);
            bgMusicInterval = null;
            return;
        }
        playNote();
    }, 250); // Faster tempo!
}

// ========================================
// üî• DOOM ENGINE - FULL RAYCASTING 3D! üî•
// ========================================

// DOOM Game State
let doomPlayer = {
    x: 1.5,
    y: 1.5,
    angle: 0,
    health: 100,
    ammo: 50
};

// Mouse control variables
let mouseEnabled = false;
let mouseSensitivity = 0.002; // –†–∞–¥–∏–∞–Ω—ã –Ω–∞ –ø–∏–∫—Å–µ–ª—å –¥–≤–∏–∂–µ–Ω–∏—è –º—ã—à–∏

// MAZE MAP! 0 = empty, 1 = wall, 2 = door
let doomMap = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1],
    [1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
    [1,0,0,2,0,1,0,0,0,1,0,2,0,1,0,1],
    [1,0,0,1,0,1,1,1,1,1,0,1,0,1,0,1],
    [1,2,0,0,0,0,0,0,0,0,0,0,0,2,0,1],
    [1,1,1,1,0,1,1,2,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
    [1,0,1,1,1,1,0,1,0,1,1,1,0,1,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],
    [1,1,1,2,1,1,0,1,1,1,0,1,2,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,2,1,1,1,1,1,0,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// DOOR SYSTEM! Each door has position and opening state
let doomDoors = [
    { x: 7, y: 1, open: 0, opening: false },  // 0 = closed, 1 = open
    { x: 3, y: 3, open: 0, opening: false },
    { x: 11, y: 3, open: 0, opening: false },
    { x: 1, y: 5, open: 0, opening: false },
    { x: 13, y: 5, open: 0, opening: false },
    { x: 7, y: 6, open: 0, opening: false },
    { x: 3, y: 10, open: 0, opening: false },
    { x: 12, y: 10, open: 0, opening: false },
    { x: 6, y: 12, open: 0, opening: false }
];

// Enemies in maze corridors!
let doomEnemies = [
    { x: 2, y: 1, health: 30, alive: true, type: 'demon' },
    { x: 9, y: 1, health: 30, alive: true, type: 'demon' },
    { x: 2, y: 5, health: 30, alive: true, type: 'demon' },
    { x: 13, y: 7, health: 30, alive: true, type: 'demon' },
    { x: 5, y: 9, health: 30, alive: true, type: 'demon' },
    { x: 10, y: 11, health: 30, alive: true, type: 'demon' },
    { x: 2, y: 13, health: 30, alive: true, type: 'demon' }
];

let doomBullets = [];
let doomAmmoPickups = [
    { x: 2, y: 2, collected: false },
    { x: 17, y: 2, collected: false },
    { x: 2, y: 17, collected: false },
    { x: 17, y: 17, collected: false },
    { x: 8, y: 5, collected: false },
    { x: 11, y: 5, collected: false },
    { x: 8, y: 14, collected: false },
    { x: 11, y: 14, collected: false },
    // MORE AMMO! üî´
    { x: 5, y: 8, collected: false },
    { x: 14, y: 8, collected: false },
    { x: 5, y: 11, collected: false },
    { x: 14, y: 11, collected: false },
    { x: 3, y: 5, collected: false },
    { x: 16, y: 5, collected: false },
    { x: 3, y: 14, collected: false },
    { x: 16, y: 14, collected: false },
    { x: 9, y: 2, collected: false },
    { x: 10, y: 2, collected: false },
    { x: 9, y: 17, collected: false },
    { x: 10, y: 17, collected: false }
];

let doomDoor = null; // 2D door reference

// Add DOOM door to 2D level
function addDoomDoorToLevel() {
    doomDoor = {
        x: 3000, // Around where player can reach
        y: 450,
        width: 60,
        height: 100,
        canEnter: true
    };
}

// Render DOOM door in 2D
function renderDoomDoor() {
    if (!doomDoor) return;
    
    const dx = doomDoor.x;
    if (dx < cameraX - 100 || dx > cameraX + canvas.width + 100) return;
    
    // Metal door with skull and red glow
    ctx.fillStyle = '#444';
    ctx.fillRect(dx, doomDoor.y, doomDoor.width, doomDoor.height);
    
    // Door frame
    ctx.fillStyle = '#666';
    ctx.fillRect(dx - 5, doomDoor.y - 5, doomDoor.width + 10, doomDoor.height + 10);
    
    // Skull symbol
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('üíÄ', dx + doomDoor.width/2, doomDoor.y + 30);
    
    // Red glow effect
    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.fillRect(dx - 10, doomDoor.y - 10, doomDoor.width + 20, doomDoor.height + 20);
    
    // "DOOM" text
    ctx.fillStyle = '#ff0000';
    ctx.font = 'bold 12px Arial';
    ctx.fillText('DOOM', dx + doomDoor.width/2, doomDoor.y + 50);
    
    ctx.textAlign = 'left';
}

// Check DOOM door collision
function checkDoomDoorCollision() {
    if (!doomDoor) return;
    
    // üîí DOOM DOOR ONLY AVAILABLE IN CONTRA!
    if (inUnderground !== 'contra') {
        return; // No DOOM door in other levels
    }
    
    if (checkCollision(player, doomDoor) && keys['ArrowDown']) {
        // Enter DOOM mode!
        gameMode = 'doom';
        console.log('üî• ENTERING DOOM MODE!');
        
        // Reset DOOM player position
        doomPlayer.x = 1.5;
        doomPlayer.y = 1.5;
        doomPlayer.angle = 0;
        doomPlayer.health = 100;
        doomPlayer.ammo = 100; // MORE AMMO! üî´
        doomPlayer.lives = 3; // LIVES SYSTEM! ‚ù§Ô∏è
        
        // Reset enemies
        doomEnemies.forEach(enemy => {
            enemy.alive = true;
            enemy.health = 30;
        });
        
        // Reset ammo pickups
        doomAmmoPickups.forEach(ammo => {
            ammo.collected = false;
        });
        
        doomBullets = [];
        
        // Request pointer lock for mouse control
        canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
        canvas.requestPointerLock();
        mouseEnabled = true;
        
        playSound('warp');
    }
}

// DOOM Update
function updateDoom() {
    // IMPROVED MOVEMENT - SMOOTHER!
    const moveSpeed = 0.08; // Faster movement
    const rotSpeed = 0.08; // Faster rotation
    
    // Smooth rotation with acceleration
    if (keys['ArrowLeft']) doomPlayer.angle -= rotSpeed;
    if (keys['ArrowRight']) doomPlayer.angle += rotSpeed;
    
    if (keys['ArrowUp']) {
        const newX = doomPlayer.x + Math.cos(doomPlayer.angle) * moveSpeed;
        const newY = doomPlayer.y + Math.sin(doomPlayer.angle) * moveSpeed;
        
        if (!isWall(newX, doomPlayer.y)) doomPlayer.x = newX;
        if (!isWall(doomPlayer.x, newY)) doomPlayer.y = newY;
    }
    
    if (keys['ArrowDown']) {
        const newX = doomPlayer.x - Math.cos(doomPlayer.angle) * moveSpeed;
        const newY = doomPlayer.y - Math.sin(doomPlayer.angle) * moveSpeed;
        
        if (!isWall(newX, doomPlayer.y)) doomPlayer.x = newX;
        if (!isWall(doomPlayer.x, newY)) doomPlayer.y = newY;
    }
    
    // Enemy AI - MOVEMENT AND ATTACKS! üëπ
    doomEnemies.forEach(enemy => {
        if (!enemy.alive) return;
        
        // Move towards player
        const dx = doomPlayer.x - enemy.x;
        const dy = doomPlayer.y - enemy.y;
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        if (distance > 0.1 && distance < 5) { // Move if not too close and not too far
            const moveSpeed = 0.02;
            const moveX = (dx / distance) * moveSpeed;
            const moveY = (dy / distance) * moveSpeed;
            
            // Check if new position is valid (not in wall)
            if (!isWall(enemy.x + moveX, enemy.y)) enemy.x += moveX;
            if (!isWall(enemy.x, enemy.y + moveY)) enemy.y += moveY;
        }
        
        // Attack player if close enough
        if (distance < 1.5 && Math.random() < 0.02) { // 2% chance per frame
            doomPlayer.health -= 5;
            if (doomPlayer.health <= 0) {
                doomPlayer.lives--; // Lose a life
                if (doomPlayer.lives <= 0) {
                    // Game over - return to 2D
                    gameMode = '2d';
                    gameOver();
                } else {
                    // Respawn with full health
                    doomPlayer.health = 100;
                    doomPlayer.x = 1.5;
                    doomPlayer.y = 1.5;
                    doomPlayer.angle = 0;
                    console.log(`üíÄ LOST LIFE! Lives remaining: ${doomPlayer.lives}`);
                }
            }
        }
    });
    
    // Ammo pickup
    doomAmmoPickups.forEach(ammo => {
        if (!ammo.collected && Math.abs(doomPlayer.x - ammo.x) < 0.5 && Math.abs(doomPlayer.y - ammo.y) < 0.5) {
            ammo.collected = true;
            doomPlayer.ammo += 30; // Increased ammo!
            score += 50;
        }
    });
    
    // Shooting
    if (keyCodes['KeyX'] && doomPlayer.ammo > 0) {
        doomPlayer.ammo--;
        doomBullets.push({
            x: doomPlayer.x,
            y: doomPlayer.y,
            angle: doomPlayer.angle,
            distance: 0,
            speed: 0.1
        });
        playSound('shoot');
        weaponRecoil = 20; // üî´ RECOIL ANIMATION!
        muzzleFlash = 5; // üí• MUZZLE FLASH!
        keyCodes['KeyX'] = false; // Prevent continuous fire
    }
    
    // Update bullets
    doomBullets = doomBullets.filter(bullet => {
        bullet.distance += bullet.speed;
        bullet.x += Math.cos(bullet.angle) * bullet.speed;
        bullet.y += Math.sin(bullet.angle) * bullet.speed;
        
        // Check wall collision
        if (isWall(bullet.x, bullet.y)) return false;
        
        // Check enemy collision
        doomEnemies.forEach(enemy => {
            if (enemy.alive && Math.abs(bullet.x - enemy.x) < 0.5 && Math.abs(bullet.y - enemy.y) < 0.5) {
                enemy.health -= 10;
                if (enemy.health <= 0) {
                    enemy.alive = false;
                    score += 100;
                }
                return false;
            }
        });
        
        return bullet.distance < 10; // Max range
    });
    
    // üö™ UPDATE AUTOMATIC DOORS!
    doomDoors.forEach(door => {
        const distToDoor = Math.sqrt((doomPlayer.x - door.x - 0.5) ** 2 + (doomPlayer.y - door.y - 0.5) ** 2);
        
        // Open door if player is close
        if (distToDoor < 1.5) {
            if (door.open < 1) {
                door.opening = true;
            }
        } else {
            // Close door if player is far
            if (door.open > 0) {
                door.opening = false;
            }
        }
        
        // Animate door opening/closing
        if (door.opening && door.open < 1) {
            door.open += 0.05; // Speed of opening
            if (door.open > 1) door.open = 1;
        } else if (!door.opening && door.open > 0) {
            door.open -= 0.05; // Speed of closing
            if (door.open < 0) door.open = 0;
        }
    });
    
    // Check exit door - ULTRA IMPROVED!
    const exitDistance = Math.sqrt((doomPlayer.x - 7.5) ** 2 + (doomPlayer.y - 0.5) ** 2);
    
    // Debug info
    if (exitDistance < 2 && Math.random() < 0.01) { // Log rarely when close
        console.log('üö™ EXIT DEBUG:', {
            playerX: doomPlayer.x.toFixed(2),
            playerY: doomPlayer.y.toFixed(2),
            exitDistance: exitDistance.toFixed(2),
            canExit: exitDistance < 1.5
        });
    }
    
    if (exitDistance < 1.5) { // Larger activation radius
        // Exit DOOM mode
        gameMode = '2d';
        mouseEnabled = false;
        
        // üéÆ PROGRESS TRACKING!
        playerProgress.doomCleared = true;
        console.log('üéØ DOOM LEVEL CLEARED!');
        
        // üö™ CREATE EXIT PIPE IN CONTRA LEVEL!
        if (inUnderground === 'contra') {
            // Create exit pipe at the end of Contra level (on the ground)
            pipes = [{
                x: 4630, // Same position as the old flag
                y: 490,  // On the ground level (same as other pipes)
                width: 60,
                height: 60,
                canEnter: true,
                isExit: true,
                isContraExit: true, // Special flag for Contra exit
                returnX: 100, // Return to main level
                color: '#00fc00' // Green pipe leading up
            }];
            console.log('üö™ EXIT PIPE CREATED IN CONTRA LEVEL!');
        }
        
        // Release pointer lock
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
        document.exitPointerLock();
        
        playSound('warp'); // Sound effect for exit
        console.log('üö™ EXITING DOOM MODE! Distance:', exitDistance.toFixed(2));
        
        // Show message
        setTimeout(() => {
            alert('üéâ DOOM LEVEL COMPLETED! üéâ\nScore: +1000 points!\nNow find the exit pipe in Contra level!');
            score += 1000;
        }, 100);
    }
}

// DOOM Helper Functions
function adjustBrightness(color, brightness) {
    // Convert hex to RGB
    const hex = color.replace('#', '');
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    // Apply brightness
    const newR = Math.floor(r * brightness);
    const newG = Math.floor(g * brightness);
    const newB = Math.floor(b * brightness);
    
    return `rgb(${newR}, ${newG}, ${newB})`;
}

function renderWallTexture(side, sideDistX, sideDistY, rayDirX, rayDirY) {
    // Calculate texture coordinates
    let wallX;
    if (side === 0) wallX = doomPlayer.y + sideDistY * rayDirY;
    else wallX = doomPlayer.x + sideDistX * rayDirX;
    wallX -= Math.floor(wallX);
    
    const textureX = Math.floor(wallX * 16);
    const wallType = Math.floor(wallX * 3) % 3;
    
    // Wall texture patterns
    const wallPatterns = {
        0: { // Stone
            base: [120, 120, 120],
            detail: [100, 100, 100],
            pattern: ['‚ñà', '‚ñì', '‚ñí', '‚ñë']
        },
        1: { // Metal
            base: [80, 80, 90],
            detail: [60, 60, 70],
            pattern: ['‚ñà', '‚ñì', '‚ñí', '‚ñë']
        },
        2: { // Rusty metal
            base: [90, 60, 40],
            detail: [70, 40, 20],
            pattern: ['‚àû', '‚óä', '‚óä', '‚àû']
        }
    };
    
    const pattern = wallPatterns[wallType];
    return {
        baseColor: pattern.base,
        detailColor: pattern.detail,
        textureX: textureX,
        pattern: pattern.pattern
    };
}

// DOOM Render
function renderDoom() {
    // Clear screen with darker background
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Raycasting
    const numRays = canvas.width;
    const fov = Math.PI / 3; // 60 degrees
    const rayAngleStep = fov / numRays;
    
    for (let i = 0; i < numRays; i++) {
        const rayAngle = doomPlayer.angle - fov/2 + i * rayAngleStep;
        const distance = castRay(doomPlayer.x, doomPlayer.y, rayAngle);
        
        // ULTRA FIXED WALL SCALING - NO STRETCHING AT ALL!
        const wallHeight = Math.max(100, Math.min(250, (canvas.height * 0.4) / distance));
        const wallTop = (canvas.height - wallHeight) / 2;
        const wallBottom = wallTop + wallHeight;
        
        // DETAILED TEXTURES WITH GRADIENT LIGHTING!
        const brightness = Math.max(0.3, 1 - distance / 8);
        
        // Calculate texture coordinates based on hit position
        const hitX = doomPlayer.x + Math.cos(rayAngle) * distance;
        const hitY = doomPlayer.y + Math.sin(rayAngle) * distance;
        const textureX = (hitX % 1) * 16; // 16 pixels per wall unit
        const textureY = (hitY % 1) * 16;
        
        // Check if this is a door
        const mapX = Math.floor(hitX);
        const mapY = Math.floor(hitY);
        const isDoor = doomMap[mapY] && doomMap[mapY][mapX] === 2;
        const door = isDoor ? doomDoors.find(d => d.x === mapX && d.y === mapY) : null;
        
        // Simple wall texture colors based on distance
        const baseColor = [
            Math.floor(120 * brightness),
            Math.floor(120 * brightness),
            Math.floor(120 * brightness)
        ];
        const detailColor = [
            Math.floor(100 * brightness),
            Math.floor(100 * brightness),
            Math.floor(100 * brightness)
        ];
        
        // Apply gradient lighting (darker at edges, brighter in center)
        const centerDist = Math.abs(i - canvas.width / 2) / (canvas.width / 2);
        const gradientFactor = 1 - centerDist * 0.3; // 30% darker at edges
        const finalBrightness = brightness * gradientFactor;
        
        // üö™ DOOR RENDERING!
        if (isDoor && door) {
            // Door opens from the side - calculate visible width
            const doorOpen = door.open; // 0 = closed, 1 = fully open
            const doorVisibleWidth = textureX / 16; // Which part of door we're seeing
            
            // If door is open enough and we're seeing the opening part, show empty space
            if (doorOpen > doorVisibleWidth) {
                // Draw empty space (door is open at this position)
                ctx.fillStyle = `rgb(${Math.floor(20 * finalBrightness)}, ${Math.floor(20 * finalBrightness)}, ${Math.floor(25 * finalBrightness)})`;
                ctx.fillRect(i, wallTop, 1, wallHeight);
            } else {
                // Draw door panel - DETAILED!
                // Metal door with panels
                const doorBaseColor = [80, 80, 90];
                const doorDetailColor = [60, 60, 70];
                
                ctx.fillStyle = `rgb(${Math.floor(doorBaseColor[0] * finalBrightness)}, ${Math.floor(doorBaseColor[1] * finalBrightness)}, ${Math.floor(doorBaseColor[2] * finalBrightness)})`;
                ctx.fillRect(i, wallTop, 1, wallHeight);
                
                // Door panels (horizontal lines)
                if (i % 2 === 0) {
                    for (let p = 0; p < wallHeight; p += Math.floor(wallHeight / 4)) {
                        ctx.fillStyle = `rgb(${Math.floor(doorDetailColor[0] * finalBrightness)}, ${Math.floor(doorDetailColor[1] * finalBrightness)}, ${Math.floor(doorDetailColor[2] * finalBrightness)})`;
                        ctx.fillRect(i, wallTop + p, 1, 2);
                    }
                }
                
                // Door edge highlight
                if (textureX < 2 || textureX > 14) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.2 * finalBrightness})`;
                ctx.fillRect(i, wallTop, 1, wallHeight);
                }
                
                // Warning stripes on door (yellow/black)
                if (Math.floor(wallTop + wallHeight * 0.5) % 16 < 8) {
                    ctx.fillStyle = `rgb(${Math.floor(200 * finalBrightness)}, ${Math.floor(180 * finalBrightness)}, ${Math.floor(0 * finalBrightness)})`;
                    ctx.fillRect(i, wallTop + wallHeight * 0.45, 1, wallHeight * 0.1);
                }
            }
        } else {
            // Normal wall
            ctx.fillStyle = `rgb(${Math.floor(baseColor[0] * finalBrightness)}, ${Math.floor(baseColor[1] * finalBrightness)}, ${Math.floor(baseColor[2] * finalBrightness)})`;
            ctx.fillRect(i, wallTop, 1, wallHeight);
            
            // Apply wall textures for non-doors
            // OPTIMIZED texture pattern - only vertical lines
            const pattern = Math.floor(textureX + i * 0.5) % 8;
            
            // Brick/panel lines (every 8 pixels)
            if (pattern === 0 || pattern === 7) {
                ctx.fillStyle = `rgb(${Math.floor(detailColor[0] * finalBrightness)}, ${Math.floor(detailColor[1] * finalBrightness)}, ${Math.floor(detailColor[2] * finalBrightness)})`;
                ctx.fillRect(i, wallTop, 1, wallHeight);
            }
            
            // Simplified horizontal lines (only every 64 pixels to reduce draw calls)
            if (wallHeight > 64 && i % 4 === 0) {
                const midY = wallTop + wallHeight / 2;
                ctx.fillStyle = `rgb(${Math.floor(detailColor[0] * finalBrightness * 0.8)}, ${Math.floor(detailColor[1] * finalBrightness * 0.8)}, ${Math.floor(detailColor[2] * finalBrightness * 0.8)})`;
                ctx.fillRect(i, midY, 1, 2);
            }
        }
        
        // FLOOR - MUCH BRIGHTER!
        const floorBrightness = Math.min(1, finalBrightness * 1.2); // Brighter!
        const floorTile = Math.floor((i + hitX * 10) / 32) % 2; // Checkerboard pattern
        
        // Base floor color (alternating tiles) - LIGHTER COLORS
        if (floorTile === 0) {
            ctx.fillStyle = `rgb(${Math.floor(90 * floorBrightness)}, ${Math.floor(70 * floorBrightness)}, ${Math.floor(50 * floorBrightness)})`;
        } else {
            ctx.fillStyle = `rgb(${Math.floor(80 * floorBrightness)}, ${Math.floor(60 * floorBrightness)}, ${Math.floor(40 * floorBrightness)})`;
        }
        ctx.fillRect(i, wallBottom, 1, canvas.height - wallBottom);
        
        // Tile grout lines (vertical) - more visible
        if (i % 32 === 0) {
            ctx.fillStyle = `rgb(${Math.floor(50 * floorBrightness)}, ${Math.floor(40 * floorBrightness)}, ${Math.floor(30 * floorBrightness)})`;
            ctx.fillRect(i, wallBottom, 1, canvas.height - wallBottom);
        }
        
        // Tile cracks/details (random sparse) - lighter
        if ((i + Math.floor(hitX * 100)) % 64 === 0) {
            ctx.fillStyle = `rgb(${Math.floor(60 * floorBrightness)}, ${Math.floor(45 * floorBrightness)}, ${Math.floor(30 * floorBrightness)})`;
            ctx.fillRect(i, wallBottom + 10, 1, 5);
        }
        
        // CEILING - MUCH BRIGHTER!
        const ceilingBrightness = Math.min(1, finalBrightness * 1.1); // Brighter!
        const ceilingPanel = Math.floor((i + hitX * 8) / 48) % 2;
        
        // Base ceiling color (alternating panels) - LIGHTER COLORS
        if (ceilingPanel === 0) {
            ctx.fillStyle = `rgb(${Math.floor(70 * ceilingBrightness)}, ${Math.floor(75 * ceilingBrightness)}, ${Math.floor(85 * ceilingBrightness)})`;
        } else {
            ctx.fillStyle = `rgb(${Math.floor(60 * ceilingBrightness)}, ${Math.floor(65 * ceilingBrightness)}, ${Math.floor(75 * ceilingBrightness)})`;
        }
        ctx.fillRect(i, 0, 1, wallTop);
        
        // Panel dividers (vertical) - more visible
        if (i % 48 === 0) {
            ctx.fillStyle = `rgb(${Math.floor(40 * ceilingBrightness)}, ${Math.floor(45 * ceilingBrightness)}, ${Math.floor(55 * ceilingBrightness)})`;
            ctx.fillRect(i, 0, 1, wallTop);
        }
        
        // Ceiling lights/vents (bright!) - more frequent
        if ((i + Math.floor(hitY * 80)) % 96 === 0 && wallTop > 10) {
            ctx.fillStyle = `rgb(${Math.floor(120 * ceilingBrightness)}, ${Math.floor(130 * ceilingBrightness)}, ${Math.floor(100 * ceilingBrightness)})`;
            ctx.fillRect(i, wallTop - 8, 1, 6);
        }
    }
    
    // Render enemies - ULTRA ENHANCED WITH SHADING!
    doomEnemies.forEach(enemy => {
        if (!enemy.alive) return;
        
        const dx = enemy.x - doomPlayer.x;
        const dy = enemy.y - doomPlayer.y;
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        if (distance < 0.1) return; // Too close
        
        const angle = Math.atan2(dy, dx) - doomPlayer.angle;
        const screenX = (angle / fov) * canvas.width + canvas.width/2;
        
        // IMPROVED BOUNDS CHECKING - NO RENDERING OUTSIDE SCREEN!
        if (screenX < -150 || screenX > canvas.width + 150) return;
        
        // Additional distance check to prevent extreme scaling
        if (distance > 15) return; // Don't render if too far
        
        // ULTRA FIXED SCALING - NO STRETCHING AT ALL!
        const enemyHeight = Math.max(40, Math.min(80, (canvas.height * 0.3) / distance));
        const enemyTop = (canvas.height - enemyHeight) / 2;
        
        // DYNAMIC LIGHTING CALCULATION
        const lightIntensity = Math.max(0.2, 1 - distance / 20); // Distance-based lighting
        const transformY = distance; // For shading calculation
        
        // ENHANCED DEMON WITH ADVANCED SHADING! üëπ
        const breathing = Math.sin(Date.now() / 300) * 0.1 + 1;
        const eyeGlow = Math.sin(Date.now() / 200) * 0.3 + 0.7;
        
        // Apply dynamic lighting filter
        ctx.filter = `brightness(${lightIntensity}) contrast(${1 + lightIntensity * 0.2})`;
        
        // Outer glow - distance dependent with enhanced shading
        ctx.globalAlpha = Math.max(0.1, 0.5 - distance * 0.05) * lightIntensity;
        ctx.fillStyle = adjustBrightness('#ff0000', lightIntensity);
        ctx.fillRect(screenX - 16, enemyTop - 8, 32, enemyHeight + 16);
        
        // Body with muscle definition and advanced shading
        ctx.globalAlpha = 1;
        const bodyColor = adjustBrightness('#8B0000', lightIntensity * 0.8);
        ctx.fillStyle = bodyColor;
        ctx.fillRect(screenX - 12, enemyTop + 5, 24, (enemyHeight - 10) * breathing);
        
        // Muscle details with shading
        ctx.fillStyle = adjustBrightness('#660000', lightIntensity * 0.6);
        ctx.fillRect(screenX - 10, enemyTop + 8, 3, 8);
        ctx.fillRect(screenX + 7, enemyTop + 8, 3, 8);
        ctx.fillRect(screenX - 6, enemyTop + 12, 12, 2);
        
        // Head with detailed structure and shading
        ctx.fillStyle = adjustBrightness('#DC143C', lightIntensity * 0.9);
        ctx.fillRect(screenX - 8, enemyTop, 16, enemyHeight * 0.4);
        
        // Jaw
        ctx.fillStyle = '#B22222';
        ctx.fillRect(screenX - 6, enemyTop + enemyHeight * 0.25, 12, 6);
        
        // Teeth/Fangs
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(screenX - 2, enemyTop + enemyHeight * 0.3, 2, 4);
        ctx.fillRect(screenX + 1, enemyTop + enemyHeight * 0.3, 2, 4);
        
        // Long horns with red tips
        ctx.fillStyle = '#2F2F2F';
        ctx.fillRect(screenX - 6, enemyTop - 5, 3, 8);
        ctx.fillRect(screenX + 3, enemyTop - 5, 3, 8);
        
        // Horn tips
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(screenX - 6, enemyTop - 6, 3, 2);
        ctx.fillRect(screenX + 3, enemyTop - 6, 3, 2);
        
        // Large eyes with white pupils
        ctx.fillStyle = '#FF0000';
        ctx.globalAlpha = eyeGlow;
        ctx.fillRect(screenX - 5, enemyTop + 3, 4, 4);
        ctx.fillRect(screenX + 1, enemyTop + 3, 4, 4);
        
        // White pupils
        ctx.fillStyle = '#FFFFFF';
        ctx.globalAlpha = 1;
        ctx.fillRect(screenX - 4, enemyTop + 4, 2, 2);
        ctx.fillRect(screenX + 2, enemyTop + 4, 2, 2);
        
        // Arms with claws
        ctx.fillStyle = '#8B0000';
        ctx.fillRect(screenX - 16, enemyTop + 8, 6, 8);
        ctx.fillRect(screenX + 10, enemyTop + 8, 6, 8);
        
        // Claws
        ctx.fillStyle = '#2F2F2F';
        ctx.fillRect(screenX - 17, enemyTop + 10, 2, 4);
        ctx.fillRect(screenX + 15, enemyTop + 10, 2, 4);
        
        // Legs
        ctx.fillStyle = '#660000';
        ctx.fillRect(screenX - 8, enemyTop + enemyHeight - 8, 4, 8);
        ctx.fillRect(screenX + 4, enemyTop + enemyHeight - 8, 4, 8);
        
        // Feet
        ctx.fillStyle = '#2F2F2F';
        ctx.fillRect(screenX - 9, enemyTop + enemyHeight - 2, 6, 4);
        ctx.fillRect(screenX + 3, enemyTop + enemyHeight - 2, 6, 4);
        
        // Inner glow effect
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#FF0000';
        ctx.fillRect(screenX - 15, enemyTop - 5, 30, enemyHeight + 10);
        ctx.globalAlpha = 1;
        
        // Reset filter after rendering demon
        ctx.filter = 'none';
    });
    
    // Render ammo pickups
    doomAmmoPickups.forEach(ammo => {
        if (ammo.collected) return;
        
        const dx = ammo.x - doomPlayer.x;
        const dy = ammo.y - doomPlayer.y;
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        if (distance < 0.1) return;
        
        const angle = Math.atan2(dy, dx) - doomPlayer.angle;
        const screenX = (angle / fov) * canvas.width + canvas.width/2;
        
        // IMPROVED BOUNDS CHECKING FOR AMMO!
        if (screenX < -50 || screenX > canvas.width + 50) return;
        
        // Distance check for ammo
        if (distance > 10) return; // Don't render if too far
        
        const ammoHeight = Math.max(15, Math.min(25, (canvas.height * 0.15) / distance));
        const ammoTop = (canvas.height - ammoHeight) / 2;
        
        // Pulsing glow effect
        const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
        
        // Outer glow
        ctx.globalAlpha = pulse * 0.4;
        ctx.fillStyle = '#FFFF00';
        ctx.fillRect(screenX - 12, ammoTop - 4, 24, ammoHeight + 8);
        
        // Main ammo box
        ctx.globalAlpha = 1;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(screenX - 8, ammoTop, 16, ammoHeight);
        
        // Box details
        ctx.fillStyle = '#FFA500';
        ctx.fillRect(screenX - 6, ammoTop + 2, 12, 2);
        ctx.fillRect(screenX - 6, ammoTop + ammoHeight - 4, 12, 2);
        
        // Ammo symbol - red cross
        ctx.fillStyle = '#FF0000';
        ctx.fillRect(screenX - 1, ammoTop + 4, 2, ammoHeight - 8);
        ctx.fillRect(screenX - 4, ammoTop + ammoHeight/2 - 1, 8, 2);
        
        // Inner glow
        ctx.globalAlpha = pulse * 0.2;
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(screenX - 10, ammoTop - 2, 20, ammoHeight + 4);
        ctx.globalAlpha = 1;
    });
    
    // RENDER EXIT DOOR IN 3D! üö™
    const exitDoorX = 7.5;
    const exitDoorY = 0.5;
    const dx = exitDoorX - doomPlayer.x;
    const dy = exitDoorY - doomPlayer.y;
    const exitDistance = Math.sqrt(dx*dx + dy*dy);
    
    if (exitDistance > 0.1 && exitDistance < 20) { // Render if not too close and not too far
        const angle = Math.atan2(dy, dx) - doomPlayer.angle;
        const screenX = (angle / fov) * canvas.width + canvas.width/2;
        
        if (screenX > -100 && screenX < canvas.width + 100) {
            const exitHeight = Math.max(60, Math.min(100, (canvas.height * 0.4) / exitDistance));
            const exitTop = (canvas.height - exitHeight) / 2;
            
            // Pulsing glow effect for exit
            const exitPulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
            
            // Outer glow - cyan
            ctx.globalAlpha = exitPulse * 0.6;
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(screenX - 20, exitTop - 10, 40, exitHeight + 20);
            
            // Main exit door
            ctx.globalAlpha = 1;
    ctx.fillStyle = '#0088ff';
            ctx.fillRect(screenX - 15, exitTop, 30, exitHeight);
            
            // Door frame
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(screenX - 16, exitTop - 2, 32, exitHeight + 4);
            
            // Exit symbol - white arrow up
    ctx.fillStyle = '#ffffff';
            const arrowSize = Math.max(4, Math.min(12, exitHeight / 4));
            // Arrow body
            ctx.fillRect(screenX - arrowSize/2, exitTop + exitHeight/2, arrowSize, arrowSize);
            // Arrow head
            ctx.fillRect(screenX - arrowSize, exitTop + exitHeight/2 - arrowSize/2, arrowSize*2, arrowSize/2);
            
            // Inner glow
            ctx.globalAlpha = exitPulse * 0.4;
    ctx.fillStyle = '#ffffff';
            ctx.fillRect(screenX - 12, exitTop + 5, 24, exitHeight - 10);
            ctx.globalAlpha = 1;
        }
    }
    
    // Render bullets
    doomBullets.forEach(bullet => {
        const dx = bullet.x - doomPlayer.x;
        const dy = bullet.y - doomPlayer.y;
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        if (distance < 0.1) return;
        
        const angle = Math.atan2(dy, dx) - doomPlayer.angle;
        const screenX = (angle / fov) * canvas.width + canvas.width/2;
        
        if (screenX < 0 || screenX > canvas.width) return;
        
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(screenX, canvas.height/2, 2, 2);
    });
    
    // HUD - ULTRA IMPROVED WITH LIVES!
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, 220, 140);
    
    // Health bar
    ctx.fillStyle = '#333333';
    ctx.fillRect(10, 10, 150, 20);
    ctx.fillStyle = '#00ff00';
    const healthPercent = doomPlayer.health / 100;
    ctx.fillRect(12, 12, 146 * healthPercent, 16);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 12px Arial';
    ctx.fillText(`HEALTH: ${doomPlayer.health}`, 10, 45);
    
    // Lives
    ctx.fillStyle = '#ff0000';
    ctx.fillText(`‚ù§Ô∏è LIVES: ${doomPlayer.lives}`, 10, 65);
    
    // Ammo
    ctx.fillStyle = '#ffff00';
    ctx.fillText(`üî´ AMMO: ${doomPlayer.ammo}`, 10, 85);
    
    // Score
    ctx.fillStyle = '#ffffff';
    ctx.fillText(`‚≠ê SCORE: ${score}`, 10, 105);
    
    // Demons
    ctx.fillStyle = '#ff0000';
    ctx.fillText(`üëπ DEMONS: ${doomEnemies.filter(e => e.alive).length}`, 10, 125);
    
    // Exit hint with distance
    const exitDist = Math.sqrt((doomPlayer.x - 7.5) ** 2 + (doomPlayer.y - 0.5) ** 2);
    ctx.fillStyle = exitDist < 2 ? '#00ff00' : '#00ffff';
    ctx.font = 'bold 10px Arial';
    ctx.fillText(`üö™ EXIT: ${exitDist.toFixed(1)}m - ${exitDist < 1.5 ? 'PRESS TO EXIT!' : 'Find cyan door!'}`, 10, 140);
    
    // Mouse control hint
    if (!mouseEnabled) {
        ctx.fillStyle = '#ffff00';
        ctx.font = 'bold 12px Arial';
        ctx.fillText('üñ±Ô∏è CLICK TO ENABLE MOUSE LOOK!', canvas.width/2 - 130, canvas.height - 20);
    } else {
        ctx.fillStyle = '#00ff00';
        ctx.font = 'bold 10px Arial';
        ctx.fillText('üñ±Ô∏è Mouse: Look | Click: Shoot | ESC: Unlock', 10, 155);
    }
    
    // Mini-map
    const mapSize = 120;
    const mapX = canvas.width - mapSize - 10;
    const mapY = 10;
    
    // Map background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(mapX, mapY, mapSize, mapSize);
    
    // Map border
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;
    ctx.strokeRect(mapX, mapY, mapSize, mapSize);
    
    // Map scale
    const mapScale = mapSize / 20;
    
    // Draw walls on map - FIXED BOUNDS!
    ctx.fillStyle = '#666666';
    for (let x = 0; x < 20; x++) {
        for (let y = 0; y < 20; y++) {
            if (isWall(x, y)) {
                // Clamp coordinates to map bounds
                const clampedX = Math.max(0, Math.min(19, x));
                const clampedY = Math.max(0, Math.min(19, y));
                ctx.fillRect(mapX + clampedX * mapScale, mapY + clampedY * mapScale, mapScale, mapScale);
            }
        }
    }
    
    // Draw player on map - CLAMPED TO BOUNDS!
    ctx.fillStyle = '#00ff00';
    const playerMapX = Math.max(0, Math.min(19, doomPlayer.x)) * mapScale;
    const playerMapY = Math.max(0, Math.min(19, doomPlayer.y)) * mapScale;
    ctx.fillRect(mapX + playerMapX - 2, mapY + playerMapY - 2, 4, 4);
    
    // Draw enemies on map - CLAMPED TO BOUNDS!
    ctx.fillStyle = '#ff0000';
    doomEnemies.forEach(enemy => {
        if (enemy.alive) {
            const enemyMapX = Math.max(0, Math.min(19, enemy.x)) * mapScale;
            const enemyMapY = Math.max(0, Math.min(19, enemy.y)) * mapScale;
            ctx.fillRect(mapX + enemyMapX - 1, mapY + enemyMapY - 1, 2, 2);
        }
    });
    
    // Draw ammo on map - CLAMPED TO BOUNDS!
    ctx.fillStyle = '#ffff00';
    doomAmmoPickups.forEach(ammo => {
        if (!ammo.collected) {
            const ammoMapX = Math.max(0, Math.min(19, ammo.x)) * mapScale;
            const ammoMapY = Math.max(0, Math.min(19, ammo.y)) * mapScale;
            ctx.fillRect(mapX + ammoMapX - 1, mapY + ammoMapY - 1, 2, 2);
        }
    });
    
    // Draw exit on map - IMPROVED WITH GLOW EFFECT!
    ctx.fillStyle = '#00ffff';
    const exitMapX = Math.max(0, Math.min(19, 7.5)) * mapScale;
    const exitMapY = Math.max(0, Math.min(19, 0.5)) * mapScale;
    
    // Glow effect
    ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
    ctx.fillRect(mapX + exitMapX - 4, mapY + exitMapY - 4, 8, 8);
    
    // Exit itself - LARGER SIZE!
    ctx.fillStyle = '#00ffff';
    ctx.fillRect(mapX + exitMapX - 3, mapY + exitMapY - 3, 6, 6);
    
    // üî´ WEAPON SPRITE - HAND WITH PISTOL!
    drawWeaponSprite();
    
    // Crosshair - IMPROVED!
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(canvas.width/2 - 8, canvas.height/2 - 1, 16, 2);
    ctx.fillRect(canvas.width/2 - 1, canvas.height/2 - 8, 2, 16);
    
    // Crosshair center
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(canvas.width/2 - 1, canvas.height/2 - 1, 2, 2);
}

// Draw weapon sprite (hand with pistol)
let weaponRecoil = 0; // Animation variable for recoil
let muzzleFlash = 0; // Muzzle flash animation
function drawWeaponSprite() {
    const baseX = canvas.width - 220;
    const baseY = canvas.height - 180 + weaponRecoil;
    
    // Decrease recoil over time
    if (weaponRecoil > 0) weaponRecoil -= 2;
    if (muzzleFlash > 0) muzzleFlash--;
    
    ctx.save();
    ctx.scale(2.5, 2.5); // Bigger for better visibility
    
    const x = baseX / 2.5;
    const y = baseY / 2.5;
    
    // === SIMPLIFIED HAND & ARM ===
    // Forearm - straight and simple
    ctx.fillStyle = '#d4a574';
    ctx.fillRect(x, y + 40, 50, 16);
    
    // Wrist
    ctx.fillStyle = '#c49564';
    ctx.fillRect(x + 45, y + 42, 8, 12);
    
    // Palm holding gun
    ctx.fillStyle = '#d4a574';
    ctx.fillRect(x + 50, y + 45, 18, 14);
    
    // Fingers on grip
    ctx.fillRect(x + 50, y + 50, 14, 10);
    
    // Thumb on top
    ctx.fillRect(x + 52, y + 42, 10, 8);
    
    // === SIMPLE PISTOL ===
    // Main gun body (slide)
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x + 60, y + 38, 42, 10);
    
    // Gun frame/grip
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(x + 52, y + 48, 16, 12);
    
    // Barrel
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(x + 98, y + 40, 12, 6);
    
    // Barrel tip
    ctx.fillStyle = '#000000';
    ctx.fillRect(x + 108, y + 41, 2, 4);
    
    // Trigger guard
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(x + 58, y + 52, 10, 2);
    
    // Trigger
    ctx.fillStyle = '#5a5a5a';
    ctx.fillRect(x + 62, y + 50, 4, 4);
    
    // Slide serrations (simplified)
    ctx.fillStyle = '#0a0a0a';
    for (let i = 0; i < 5; i++) {
        ctx.fillRect(x + 65 + i * 6, y + 39, 3, 2);
    }
    
    // Front sight
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(x + 94, y + 36, 3, 4);
    
    // Rear sight
    ctx.fillStyle = '#4a4a4a';
    ctx.fillRect(x + 66, y + 36, 2, 4);
    ctx.fillRect(x + 72, y + 36, 2, 4);
    
    // Metal highlight
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.fillRect(x + 75, y + 39, 18, 2);
    
    // === MUZZLE FLASH! ===
    if (muzzleFlash > 0) {
        // Bright yellow/orange flash from barrel
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(x + 106, y + 39, 10, 8);
        
        ctx.fillStyle = '#ff8800';
        ctx.fillRect(x + 112, y + 40, 8, 6);
        
        ctx.fillStyle = '#ff4400';
        ctx.fillRect(x + 116, y + 41, 6, 4);
        
        // Flash glow
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(x + 104, y + 37, 16, 12);
        ctx.globalAlpha = 1;
    }
    
    ctx.restore();
}

// Raycasting function
function castRay(startX, startY, angle) {
    const maxDistance = 20;
    const stepSize = 0.01;
    
    let distance = 0;
    let x = startX;
    let y = startY;
    
    while (distance < maxDistance) {
        x += Math.cos(angle) * stepSize;
        y += Math.sin(angle) * stepSize;
        distance += stepSize;
        
        if (isWall(x, y)) {
            return distance;
        }
    }
    
    return maxDistance;
}

// Check if position is a wall
function isWall(x, y) {
    const mapX = Math.floor(x);
    const mapY = Math.floor(y);
    
    if (mapX < 0 || mapX >= doomMap[0].length || mapY < 0 || mapY >= doomMap.length) {
        return true;
    }
    
    const cell = doomMap[mapY][mapX];
    
    // If it's a door, check if it's closed
    if (cell === 2) {
        const door = doomDoors.find(d => d.x === mapX && d.y === mapY);
        if (door) {
            return door.open < 0.7; // Door blocks if not mostly open
        }
    }
    
    return cell === 1;
}

// Add DOOM door collision check to main update (already integrated above)

// üéÆ CHEAT CODE SYSTEM
function showCheatInput() {
    document.getElementById('cheatInput').style.display = 'block';
    document.getElementById('cheatCodeInput').focus();
}

function closeCheatInput() {
    document.getElementById('cheatInput').style.display = 'none';
    document.getElementById('cheatCodeInput').value = '';
}

// üîä SOUND TOGGLE FUNCTION
function toggleSound() {
    soundEnabled = !soundEnabled;
    const soundButton = document.getElementById('soundToggle');
    
    if (soundEnabled) {
        soundButton.textContent = 'üîä';
        soundButton.style.background = 'rgba(0, 0, 0, 0.9)';
        soundButton.style.color = '#fcfc00';
    } else {
        soundButton.textContent = 'üîá';
        soundButton.style.background = 'rgba(255, 0, 0, 0.9)';
        soundButton.style.color = '#ffffff';
        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å—é –º—É–∑—ã–∫—É –ø—Ä–∏ –≤—ã–∫–ª—é—á–µ–Ω–∏–∏ –∑–≤—É–∫–∞
        stopBackgroundMusic();
    }
    
    // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è (–µ—Å–ª–∏ –∑–≤—É–∫ –≤–∫–ª—é—á–µ–Ω)
    if (soundEnabled) {
        playSound('coin');
    }
}

function executeCheat() {
    const cheatCode = document.getElementById('cheatCodeInput').value.toLowerCase().trim();
    
    switch(cheatCode) {
        case 'godmode':
            if (player.godMode) {
                // –û—Ç–∫–ª—é—á–∞–µ–º godmode –∏ —Å—É–ø–µ—Ä –æ—Ä—É–∂–∏–µ
                player.invincible = false;
                player.godMode = false;
                player.canShoot = false; // –û—Ç–∫–ª—é—á–∞–µ–º —Å—Ç—Ä–µ–ª—å–±—É
                player.fireRate = 10; // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—ã—á–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å —Å—Ç—Ä–µ–ª—å–±—ã
                player.bulletDamage = 1; // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—ã—á–Ω—ã–π —É—Ä–æ–Ω
                console.log('üõ°Ô∏è CHEAT: GODMODE DEACTIVATED - Normal gameplay restored!');
            } else {
                // –í–∫–ª—é—á–∞–µ–º godmode + —Å—É–ø–µ—Ä –æ—Ä—É–∂–∏–µ
                player.invincible = true;
                player.godMode = true; // –ü–æ–ª–Ω–∞—è –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç—å –æ—Ç –≤—Å–µ—Ö –≤–∏–¥–æ–≤ —É—Ä–æ–Ω–∞
                player.canShoot = true; // –í–∫–ª—é—á–∞–µ–º —Å—Ç—Ä–µ–ª—å–±—É
                player.fireRate = 0; // –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è —Å—Ç—Ä–µ–ª—å–±–∞
                player.bulletDamage = 999; // –£—Ä–æ–Ω 999 (–æ–¥–Ω–æ –≤—ã—Å—Ç—Ä–µ–ª = —Å–º–µ—Ä—Ç—å)
                player.bullets = []; // –û—á–∏—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø—É–ª–∏
                console.log('üõ°Ô∏èüî´ CHEAT: GODMODE + SUPER WEAPON ACTIVATED!');
                console.log('  - Full invincibility from all damage');
                console.log('  - Instant shooting with 999 damage');
                console.log('  - Unlimited ammo');
            }
            break;
        case 'noclip':
            player.noclip = !player.noclip;
            break;
        case 'keys':
            playerProgress.hasKey1 = true;
            playerProgress.hasKey2 = true;
            break;
        case 'ammo':
            if (player.canShoot) {
                player.bullets = [];
            }
            break;
        case 'level':
            level = Math.min(5, level + 1);
            initLevel();
            break;
        case 'score':
            score += 10000;
            break;
        case 'doom':
            if (inUnderground === 'contra') {
                gameMode = 'doom';
                doomPlayer.x = 1.5;
                doomPlayer.y = 1.5;
                doomPlayer.angle = 0;
                doomPlayer.health = 100;
                doomPlayer.ammo = 100;
                doomPlayer.lives = 5;
            }
            break;
        case 'superboss':
            if (!inUnderground) {
                checkAndSpawnSuperBoss();
            }
            break;
        case 'teleport':
            if (!inUnderground) {
                // Teleport to super boss area
                player.x = LEVEL_WIDTH - 500; // Near super boss
                cameraX = Math.max(0, player.x - 400);
                // Ensure all progress is unlocked
                playerProgress.undergroundCleared = true;
                playerProgress.contraCleared = true;
                playerProgress.doomCleared = true;
                // Spawn super boss if not already spawned
                checkAndSpawnSuperBoss();
            }
            break;
        case 'space':
            // Direct transition to space mode
            console.log('üåå CHEAT: ENTERING SPACE MODE!');
            initSpaceMode({
                playerHealth: lives * 25, // Convert lives to health
                onExit: (result) => {
                    console.log('üåå SPACE MODE RESULT:', result);
                    if (result.victory) {
                        // Final victory - complete the game
                        gameRunning = false;
                        stopBackgroundMusic();
                        score += result.score; // Add space score to main score
                        document.getElementById('victoryScore').textContent = score;
                        document.getElementById('victoryScreen').style.display = 'block';
                        playSound('victory');
                    } else {
                        // Return to main game
                        gameRunning = true;
                        // Reset player position
                        player.x = 200;
                        player.y = 400;
                        cameraX = 0;
                    }
                }
            });
            break;
        case 'sound':
            // Toggle sound on/off
            toggleSound();
            break;
        case 'killall':
            // Kill all enemies and bosses
            enemies.forEach(enemy => {
                enemy.health = 0;
                enemy.alive = false;
            });
            if (currentBoss && currentBoss.alive) {
                currentBoss.health = 0;
                currentBoss.alive = false;
            }
            console.log('üíÄ CHEAT: ALL ENEMIES KILLED!');
            break;
        case 'superweapon':
            // Give super weapon - unlimited ammo, fire rate, damage
            player.canShoot = true;
            player.fireRate = 0; // Instant shooting
            player.bulletDamage = 999; // One-shot kill
            player.bullets = []; // Clear existing bullets
            console.log('üî´ CHEAT: SUPER WEAPON ACTIVATED!');
            console.log('üí° TIP: Use "godmode" for invincibility + super weapon combo!');
            break;
        case 'secretroom':
            // Teleport directly to secret room
            if (inUnderground) {
                player.x = 4200;
                cameraX = Math.max(0, player.x - 400);
                console.log('üèóÔ∏è CHEAT: TELEPORTED TO SECRET ROOM!');
            } else {
                console.log('‚ùå CHEAT: Must be in underground level!');
            }
            break;
        case 'underground':
            // Enter underground level directly
            if (!inUnderground) {
                createUndergroundLevel(1000);
                console.log('üï≥Ô∏è CHEAT: ENTERED UNDERGROUND LEVEL!');
            }
            break;
        case 'help':
            // Show all available cheats
            console.log('üéÆ AVAILABLE CHEATS:');
            console.log('  godmode - Invincibility + Super Weapon (toggle)');
            console.log('  noclip - Walk through walls');
            console.log('  keys - Get all keys');
            console.log('  ammo - Refill ammo');
            console.log('  level - Next level');
            console.log('  score - +10000 score');
            console.log('  doom - Enter DOOM mode');
            console.log('  superboss - Spawn super boss');
            console.log('  teleport - Teleport to boss area');
            console.log('  space - Enter space mode');
            console.log('  sound - Toggle sound');
            console.log('  killall - Kill all enemies');
            console.log('  superweapon - Super weapon only');
            console.log('  secretroom - Teleport to secret room');
            console.log('  underground - Enter underground');
            break;
        default:
            // –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —á–∏—Ç - –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
    }
    
    closeCheatInput();
}

// Keyboard shortcut to open cheat input (F9 key)
document.addEventListener('keydown', function(e) {
    if (e.key === 'F9') {
        e.preventDefault();
        showCheatInput();
    }
    if (e.key === 'Escape') {
        closeCheatInput();
    }
});

// ==========================================
// SPACE MODE - EMBEDDED IN GAME
// ==========================================

let spaceMode = {
    active: false,
    canvas: null,
    ctx: null,
    gameState: { active: false, playerHP: 100, maxHP: 100, score: 0 },
    player: { x: 0, y: 0, vx: 0, vy: 0, width: 40, height: 40, speed: 5 },
    boss: { x: 0, y: 0, width: 80, height: 80, hp: 50, maxHP: 50, vx: 2, attackTimer: 0 },
    playerBullets: [],
    bossBullets: [],
    asteroids: [],
    particles: [],
    keys: {},
    sprites: {},
    onExit: null
};

function initSpaceMode(config) {
    console.log('üåå ENTERING SPACE MODE!');
    
    spaceMode.onExit = config.onExit || (() => {});
    spaceMode.gameState.playerHP = config.playerHealth || 100;
    spaceMode.gameState.maxHP = config.playerHealth || 100;
    spaceMode.gameState.score = 0;
    
    // Hide main canvas
    canvas.style.display = 'none';
    gameRunning = false;
    
    // Create space overlay
    if (!spaceMode.canvas) {
        spaceMode.canvas = document.createElement('canvas');
        spaceMode.canvas.id = 'spaceCanvas';
        spaceMode.canvas.width = window.innerWidth;
        spaceMode.canvas.height = window.innerHeight;
        spaceMode.canvas.style.cssText = 'position:fixed;top:0;left:0;z-index:9999;background:#000515;display:block;';
        document.body.appendChild(spaceMode.canvas);
        
        spaceMode.ctx = spaceMode.canvas.getContext('2d');
        spaceMode.ctx.imageSmoothingEnabled = false;
        
        // Load sprites
        loadSpaceSprites();
        
        // Setup input
        setupSpaceInput();
    }
    
    // Reset game
    spaceMode.player.x = spaceMode.canvas.width / 2;
    spaceMode.player.y = spaceMode.canvas.height - 100;
    spaceMode.player.vx = 0;
    spaceMode.player.vy = 0;
    
    spaceMode.boss.x = spaceMode.canvas.width / 2;
    spaceMode.boss.y = 150;
    spaceMode.boss.hp = 50;
    spaceMode.boss.attackTimer = 0;
    
    spaceMode.playerBullets = [];
    spaceMode.bossBullets = [];
    spaceMode.asteroids = [];
    spaceMode.particles = [];
    
    spaceMode.gameState.active = true;
    spaceMode.active = true;
    
    // Create UI only for space mode
    createSpaceUI();
    
    spawnSpaceAsteroids();
    spaceGameLoop();
}

function loadSpaceSprites() {
    spaceMode.sprites = {
        asteroid: new Image(),
        asteroidExplode: new Image(),
        planet: new Image(),
        flame: new Image()
    };
    // Ensure flags container exists for sprite error handling/retries
    spaceMode.flags = spaceMode.flags || { skipPlanet: false, triedAltPlanet: false };
    
    // Add load event listeners to ensure sprites are fully loaded
    spaceMode.sprites.asteroid.onload = () => {
        console.log('‚úÖ Asteroid sprite loaded');
    };
    spaceMode.sprites.asteroid.onerror = () => {
        console.log('‚ùå Asteroid sprite failed to load');
    };
    
    spaceMode.sprites.planet.onload = () => {
        console.log('‚úÖ Planet sprite loaded');
        spaceMode.flags.skipPlanet = false;
    };
    spaceMode.sprites.planet.onerror = () => {
        console.log('‚ùå Planet sprite failed to load');
        // Try an alternate filename once (without the "Without back glow" suffix)
        if (!spaceMode.flags.triedAltPlanet) {
            spaceMode.flags.triedAltPlanet = true;
            try {
                const original = '/static/images/sprites/void/Planets/PNGs/Earth-Like planet - Without back glow.png';
                const alternative = '/static/images/sprites/void/Planets/PNGs/Earth-Like planet.png';
                // Only switch if currently pointing to the original path
                if (spaceMode.sprites.planet.src.endsWith('Earth-Like%20planet%20-%20Without%20back%20glow.png') ||
                    spaceMode.sprites.planet.src.endsWith('Earth-Like planet - Without back glow.png')) {
                    spaceMode.sprites.planet.src = alternative;
                    console.log('‚Ü©Ô∏è Retrying planet sprite with alternative path:', alternative);
                    return;
                }
            } catch (e) {
                // no-op
            }
        }
        // If retry failed or not applicable, disable planet rendering to avoid artifacts
        spaceMode.flags.skipPlanet = true;
    };
    
    spaceMode.sprites.asteroidExplode.onload = () => {
        console.log('‚úÖ Asteroid explode sprite loaded');
    };
    spaceMode.sprites.asteroidExplode.onerror = () => {
        console.log('‚ùå Asteroid explode sprite failed to load');
    };
    
    spaceMode.sprites.flame.onload = () => {
        console.log('‚úÖ Flame sprite loaded');
    };
    spaceMode.sprites.flame.onerror = () => {
        console.log('‚ùå Flame sprite failed to load');
    };
    
    // Set sources after event listeners
    spaceMode.sprites.asteroid.src = '/static/images/sprites/void/Asteroids/PNGs/Asteroid 01 - Base.png';
    spaceMode.sprites.asteroidExplode.src = '/static/images/sprites/void/Asteroids/PNGs/Asteroid 01 - Explode.png';
    spaceMode.sprites.planet.src = '/static/images/sprites/void/Planets/PNGs/Earth-Like planet - Without back glow.png';
    spaceMode.sprites.flame.src = '/static/images/sprites/void/Effects/PNGs/Asteroid - Flame.png';
    
    console.log('üåå Loading space sprites...');
    console.log('Asteroid:', spaceMode.sprites.asteroid.src);
    console.log('Planet:', spaceMode.sprites.planet.src);
    console.log('Flame:', spaceMode.sprites.flame.src);
}

// Helper function to safely check if sprite is loaded (no verbose logs to avoid frame drops)
function isSpriteLoaded(sprite) {
    if (!sprite) {
        return false;
    }
    if (!sprite.complete) {
        return false;
    }
    if (sprite.naturalWidth <= 0 || sprite.naturalHeight <= 0) {
        return false;
    }
    if (sprite.error) {
        return false;
    }
    if (!sprite.src || sprite.src === '') {
        return false;
    }
    return true;
}

function setupSpaceInput() {
    const spaceKeyHandler = (e) => {
        spaceMode.keys[e.key] = true;
        
        if (e.key === ' ') {
            e.preventDefault();
            shootSpaceBullet();
        }
        
        if (e.key === 'Escape') {
            exitSpaceMode();
        }
    };
    
    const spaceKeyUpHandler = (e) => {
        spaceMode.keys[e.key] = false;
    };
    
    document.addEventListener('keydown', spaceKeyHandler);
    document.addEventListener('keyup', spaceKeyUpHandler);
    
    // Store handlers for cleanup
    spaceMode.keyHandlers = { down: spaceKeyHandler, up: spaceKeyUpHandler };
}

function shootSpaceBullet() {
    if (!spaceMode.gameState.active) return;
    spaceMode.playerBullets.push({
        x: spaceMode.player.x + spaceMode.player.width / 2,
        y: spaceMode.player.y,
        vx: 0,
        vy: -8,
        width: 4,
        height: 12
    });
}

function spawnSpaceAsteroids() {
    for (let i = 0; i < 8; i++) {
        spaceMode.asteroids.push({
            x: Math.random() * spaceMode.canvas.width,
            y: Math.random() * (spaceMode.canvas.height * 0.5),
            vx: (Math.random() - 0.5) * 3,
            vy: Math.random() * 2 + 1,
            size: 30 + Math.random() * 40,
            rotation: Math.random() * Math.PI * 2,
            rotSpeed: (Math.random() - 0.5) * 0.1,
            hp: 2
        });
    }
}

function createSpaceExplosion(x, y, color) {
    for (let i = 0; i < 8; i++) {
        spaceMode.particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            color: color,
            life: 30
        });
    }
}

function updateSpaceGame() {
    if (!spaceMode.gameState.active) return;
    
    // Player movement
    if (spaceMode.keys['ArrowLeft']) spaceMode.player.vx = -spaceMode.player.speed;
    else if (spaceMode.keys['ArrowRight']) spaceMode.player.vx = spaceMode.player.speed;
    else spaceMode.player.vx *= 0.9;

    if (spaceMode.keys['ArrowUp']) spaceMode.player.vy = -spaceMode.player.speed;
    else if (spaceMode.keys['ArrowDown']) spaceMode.player.vy = spaceMode.player.speed;
    else spaceMode.player.vy *= 0.9;

    spaceMode.player.x += spaceMode.player.vx;
    spaceMode.player.y += spaceMode.player.vy;

    spaceMode.player.x = Math.max(0, Math.min(spaceMode.player.x, spaceMode.canvas.width - spaceMode.player.width));
    spaceMode.player.y = Math.max(0, Math.min(spaceMode.player.y, spaceMode.canvas.height - spaceMode.player.height));

    // Boss attacks
    spaceMode.boss.attackTimer++;
    if (spaceMode.boss.attackTimer > 40) {
        spaceMode.boss.attackTimer = 0;
        for (let i = 0; i < 3; i++) {
            const angle = (i - 1) * 0.3;
            spaceMode.bossBullets.push({
                x: spaceMode.boss.x + spaceMode.boss.width / 2,
                y: spaceMode.boss.y + spaceMode.boss.height / 2,
                vx: Math.sin(angle) * 4,
                vy: Math.cos(angle) * 4,
                width: 8,
                height: 8
            });
        }
    }

    spaceMode.boss.x += spaceMode.boss.vx;
    if (spaceMode.boss.x < 50 || spaceMode.boss.x > spaceMode.canvas.width - 100) spaceMode.boss.vx *= -1;

    // Player bullets
    spaceMode.playerBullets = spaceMode.playerBullets.filter(bullet => {
        bullet.x += bullet.vx;
        bullet.y += bullet.vy;

        if (bullet.x > spaceMode.boss.x && bullet.x < spaceMode.boss.x + spaceMode.boss.width &&
            bullet.y > spaceMode.boss.y && bullet.y < spaceMode.boss.y + spaceMode.boss.height) {
            spaceMode.boss.hp--;
            spaceMode.gameState.score += 100;
            createSpaceExplosion(bullet.x, bullet.y, '#ffaa00');
            
            if (spaceMode.boss.hp <= 0) {
                spaceMode.gameState.score += 5000;
                spaceVictory();
            }
            return false;
        }

        let hitAsteroid = false;
        spaceMode.asteroids.forEach(ast => {
            const dist = Math.hypot(ast.x - bullet.x, ast.y - bullet.y);
            if (dist < ast.size / 2) {
                ast.hp--;
                spaceMode.gameState.score += 50;
                createSpaceExplosion(ast.x, ast.y, '#ff8800');
                hitAsteroid = true;
            }
        });

        return !hitAsteroid && bullet.y > 0;
    });

    // Boss bullets
    spaceMode.bossBullets = spaceMode.bossBullets.filter(bullet => {
        bullet.x += bullet.vx;
        bullet.y += bullet.vy;

        if (bullet.x > spaceMode.player.x && bullet.x < spaceMode.player.x + spaceMode.player.width &&
            bullet.y > spaceMode.player.y && bullet.y < spaceMode.player.y + spaceMode.player.height) {
            spaceMode.gameState.playerHP -= 10;
            createSpaceExplosion(spaceMode.player.x, spaceMode.player.y, '#ff0000');
            if (spaceMode.gameState.playerHP <= 0) {
                exitSpaceMode();
            }
            return false;
        }

        return bullet.x > 0 && bullet.x < spaceMode.canvas.width && bullet.y > 0 && bullet.y < spaceMode.canvas.height;
    });

    // Asteroids
    spaceMode.asteroids = spaceMode.asteroids.filter(ast => {
        ast.x += ast.vx;
        ast.y += ast.vy;
        ast.rotation += ast.rotSpeed;

        const dist = Math.hypot(ast.x - spaceMode.player.x, ast.y - spaceMode.player.y);
        if (dist < ast.size / 2 + spaceMode.player.width / 2) {
            spaceMode.gameState.playerHP -= 5;
            createSpaceExplosion(spaceMode.player.x, spaceMode.player.y, '#ff0000');
            if (spaceMode.gameState.playerHP <= 0) exitSpaceMode();
        }

        if (ast.hp <= 0) {
            createSpaceExplosion(ast.x, ast.y, '#ffaa00');
            return false;
        }

        return ast.y < spaceMode.canvas.height;
    });

    // Particles
    spaceMode.particles = spaceMode.particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        return p.life > 0;
    });

    updateSpaceUI();
}

function renderSpaceGame() {
    const ctx = spaceMode.ctx;
    const w = spaceMode.canvas.width;
    const h = spaceMode.canvas.height;
    
    // Clear canvas first to prevent artifacts
    ctx.clearRect(0, 0, w, h);
    
    // Background
    ctx.fillStyle = '#000515';
    ctx.fillRect(0, 0, w, h);

    // Stars
    ctx.fillStyle = '#ffffff';
    ctx.globalAlpha = 0.6;
    for (let i = 0; i < 200; i++) {
        const x = (i * 73) % w;
        const y = (i * 97) % h;
        const size = (i % 3) + 1;
        ctx.fillRect(x, y, size, size);
    }
    ctx.globalAlpha = 1;

    // Planet (render only if not skipped and fully loaded)
    if (!spaceMode.flags?.skipPlanet && isSpriteLoaded(spaceMode.sprites.planet)) {
        ctx.globalAlpha = 0.25;
        const planetSize = 180;
        ctx.drawImage(spaceMode.sprites.planet, w - planetSize - 40, 30, planetSize, planetSize);
        ctx.globalAlpha = 1;
    } else if (!spaceMode.flags?.skipPlanet) {
        // Fallback: —Ä–∏—Å—É–µ–º –ø—Ä–æ—Å—Ç—É—é –ø–ª–∞–Ω–µ—Ç—É
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#4a4a8a';
        ctx.beginPath();
        ctx.arc(w - 130, 120, 90, 0, Math.PI * 2);
        ctx.fill();
        
        // –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ç–∞–ª–∏
        ctx.fillStyle = '#6a6aaa';
        ctx.beginPath();
        ctx.arc(w - 150, 100, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(w - 110, 140, 15, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 1;
    }

    // Asteroids (—Ä–∏—Å—É–µ–º –î–û –≤—Å–µ–≥–æ –æ—Å—Ç–∞–ª—å–Ω–æ–≥–æ)
    spaceMode.asteroids.forEach(ast => {
        if (isSpriteLoaded(spaceMode.sprites.asteroid)) {
            // –†–∏—Å—É–µ–º —Å–ø—Ä–∞–π—Ç –∞—Å—Ç–µ—Ä–æ–∏–¥–∞
            ctx.save();
            ctx.translate(ast.x, ast.y);
            ctx.rotate(ast.rotation);
            ctx.drawImage(spaceMode.sprites.asteroid, -ast.size/2, -ast.size/2, ast.size, ast.size);
            ctx.restore();
        } else {
            // Fallback: —Ä–∏—Å—É–µ–º —Å–µ—Ä—ã–π –∫–≤–∞–¥—Ä–∞—Ç
            ctx.save();
            ctx.translate(ast.x, ast.y);
            ctx.rotate(ast.rotation);
            ctx.fillStyle = '#6a5a4a';
            ctx.fillRect(-ast.size/2, -ast.size/2, ast.size, ast.size);
            ctx.restore();
        }
    });

    // Boss
    ctx.fillStyle = '#ff0000';
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 20;
    ctx.fillRect(spaceMode.boss.x, spaceMode.boss.y, spaceMode.boss.width, spaceMode.boss.height);
    ctx.shadowBlur = 0;
    
    ctx.fillStyle = '#ff0000';
    ctx.font = 'bold 12px Courier New';
    ctx.fillText('BOSS: ' + Math.max(0, spaceMode.boss.hp), spaceMode.boss.x + 10, spaceMode.boss.y - 10);

    // Player (–∫–æ—Ä–∞–±–ª—å)
    ctx.fillStyle = '#00ff00';
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.moveTo(spaceMode.player.x + 20, spaceMode.player.y);
    ctx.lineTo(spaceMode.player.x + 40, spaceMode.player.y + 40);
    ctx.lineTo(spaceMode.player.x + 20, spaceMode.player.y + 28);
    ctx.lineTo(spaceMode.player.x, spaceMode.player.y + 40);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;

    // Player bullets
    ctx.fillStyle = '#00ff00';
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 5;
    spaceMode.playerBullets.forEach(b => {
        ctx.fillRect(b.x, b.y, b.width, b.height);
    });
    ctx.shadowBlur = 0;

    // Boss bullets
    ctx.fillStyle = '#ff6600';
    ctx.shadowColor = '#ff6600';
    ctx.shadowBlur = 8;
    spaceMode.bossBullets.forEach(b => {
        ctx.beginPath();
        ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.shadowBlur = 0;

    // Particles
    spaceMode.particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 30;
        ctx.fillRect(p.x, p.y, 3, 3);
        ctx.globalAlpha = 1;
    });
}

function updateSpaceUI() {
    if (!spaceMode.active) return;
    if (!document.getElementById('spaceUI')) return;
    const hpPercent = (spaceMode.boss.hp / spaceMode.boss.maxHP) * 100;
    const fill = document.getElementById('bossHPFill');
    if (fill) fill.style.width = hpPercent + '%';
    
    const hpText = document.getElementById('playerHPText');
    if (hpText) hpText.textContent = Math.max(0, spaceMode.gameState.playerHP);
    
    const scoreText = document.getElementById('scoreText');
    if (scoreText) scoreText.textContent = spaceMode.gameState.score;
}

function spaceGameLoop() {
    if (!spaceMode.gameState.active) return;
    updateSpaceGame();
    renderSpaceGame();
    requestAnimationFrame(spaceGameLoop);
}

function spaceVictory() {
    spaceMode.gameState.active = false;
    document.getElementById('spaceFinalScore').textContent = spaceMode.gameState.score;
    document.getElementById('spaceVictory').style.display = 'block';
    
    setTimeout(() => {
        exitSpaceMode();
    }, 3000);
}

function exitSpaceMode() {
    spaceMode.active = false;
    spaceMode.gameState.active = false;
    
    if (spaceMode.canvas) {
        spaceMode.canvas.style.display = 'none';
    }
    
    canvas.style.display = 'block';
    gameRunning = true;
    
    // Remove space UI if exists
    const ui = document.getElementById('spaceUI');
    if (ui && ui.parentNode) ui.parentNode.removeChild(ui);
    const victory = document.getElementById('spaceVictory');
    if (victory && victory.parentNode) victory.parentNode.removeChild(victory);
    
    if (spaceMode.onExit) {
        spaceMode.onExit({
            health: spaceMode.gameState.playerHP,
            score: spaceMode.gameState.score,
            victory: spaceMode.boss.hp <= 0
        });
    }
    
    console.log('üåå EXITED SPACE MODE!');
}

// HTML –î–õ–Ø UI
function createSpaceUI() {
    if (document.getElementById('spaceUI')) return;
    
    const ui = document.createElement('div');
    ui.id = 'spaceUI';
    ui.style.cssText = 'position:fixed;top:15px;left:15px;color:#00ff00;font-family:"Courier New",monospace;font-size:13px;z-index:100;background:rgba(0,0,0,0.85);padding:15px;border:2px solid #ffaa00;box-shadow:0 0 10px #ffaa00;line-height:1.8;';
    ui.innerHTML = `
        <div>‚≠ê SPACE ARENA ‚≠ê</div>
        <div style="margin-top:8px;">HP: <span id="playerHPText">100</span>/100</div>
        <div id="bossHPBar" style="width:300px;height:20px;background:#000;border:2px solid #ff0000;margin:10px 0;"><div id="bossHPFill" style="height:100%;background:linear-gradient(90deg,#ff0000,#ff8800);box-shadow:0 0 10px #ff0000;width:100%;transition:width 0.2s;"></div></div>
        <div style="margin-top:8px;color:#ffaa00;">SCORE: <span id="scoreText">0</span></div>
        <div style="margin-top:12px;font-size:11px;color:#666;">ARROWS - MOVE | SPACE - SHOOT | ESC - EXIT</div>
    `;
    document.body.appendChild(ui);
    
    const victory = document.createElement('div');
    victory.id = 'spaceVictory';
    victory.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);padding:40px;border:3px solid #00ff00;text-align:center;color:#00ff00;font-family:"Courier New",monospace;z-index:200;display:none;box-shadow:0 0 30px #00ff00;';
    victory.innerHTML = `
        <h1 style="font-size:32px;margin:20px 0;text-shadow:0 0 20px #00ff00;">üéâ VICTORY! üéâ</h1>
        <p style="font-size:16px;margin:10px 0;">YOU DEFEATED THE BOSS!</p>
        <p style="font-size:14px;">FINAL SCORE: <span id="spaceFinalScore">0</span></p>
    `;
    document.body.appendChild(victory);
}

// Space UI —Å–æ–∑–¥–∞—ë—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ –∫–æ—Å–º–æ—Å (initSpaceMode)
</script>
{% endblock %}

