{% extends "games/base_game.html" %}

{% block title %}Dentist Dash - 8-Bit Game{% endblock %}

{% block game_content %}
<style>
    /* 8-BIT RETRO STYLING */
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    
    * {
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
    }
    
    body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: 'Press Start 2P', cursive;
    }
    
    #gameCanvas {
        display: block;
        margin: 0 auto;
        background: #5c94fc;
        border: 8px solid #222;
        box-shadow: 
            0 0 0 4px #444,
            0 0 20px rgba(0,0,0,0.8),
            inset 0 0 100px rgba(0,0,0,0.3);
    }
    
    .game-container {
        position: relative;
        max-width: 800px;
        margin: 20px auto;
    }
    
    .hud {
        position: absolute;
        top: 10px;
        left: 10px;
        right: 10px;
        color: #fff;
        font-size: 12px;
        text-shadow: 2px 2px 0 #000;
        display: flex;
        justify-content: space-between;
        z-index: 10;
        pointer-events: none;
    }
    
    .game-over-screen,
    .start-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 30px;
        border: 4px solid #fff;
        text-align: center;
        color: #fff;
        font-size: 14px;
        display: none;
        z-index: 100;
    }
    
    .start-screen {
        display: block;
    }
    
    .start-screen h1 {
        font-size: 24px;
        margin: 0 0 20px 0;
        color: #fcfc00;
        text-shadow: 3px 3px 0 #fc0000;
    }
    
    .pixel-btn {
        background: #fcfc00;
        color: #000;
        border: 4px solid #fff;
        padding: 10px 20px;
        font-family: 'Press Start 2P', cursive;
        font-size: 12px;
        cursor: pointer;
        margin: 10px;
        transition: all 0.1s;
    }
    
    .pixel-btn:hover {
        background: #fc0000;
        color: #fff;
        transform: scale(1.05);
    }
    
    .pixel-btn:active {
        transform: scale(0.95);
    }
    
    .instructions {
        margin: 20px 0;
        font-size: 10px;
        line-height: 1.8;
        color: #aaa;
    }
    
    .lives {
        color: #fc0000;
    }
    
    .score {
        color: #fcfc00;
    }
    
    .level {
        color: #00fc00;
    }
    
    /* CRT Effect */
    #gameCanvas::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
            rgba(18, 16, 16, 0) 50%, 
            rgba(0, 0, 0, 0.25) 50%
        );
        background-size: 100% 4px;
        pointer-events: none;
    }
</style>

<div class="game-container">
    <!-- HUD -->
    <div class="hud">
        <div class="score">SCORE: <span id="scoreDisplay">0</span></div>
        <div class="level">LEVEL: <span id="levelDisplay">1</span></div>
        <div class="lives">LIVES: <span id="livesDisplay">3</span></div>
    </div>
    
    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
        <h1>ü¶∑ DENTIST DASH ü¶∑</h1>
        <p style="color: #00fc00; margin: 20px 0;">A RETRO 8-BIT ADVENTURE</p>
        <div class="instructions">
            ‚¨ÖÔ∏è ‚û°Ô∏è MOVE<br>
            ‚¨ÜÔ∏è JUMP<br>
            ü¶† AVOID BACTERIA<br>
            üíä COLLECT POWER-UPS<br>
            üîë FIND SECRET KEYS<br>
        </div>
        <button class="pixel-btn" onclick="startGame()">START GAME</button>
        <p style="font-size: 8px; color: #555; margin-top: 20px;">
            ¬© 2025 MENTORA GAMES
        </p>
    </div>
    
    <!-- Game Over Screen -->
    <div class="game-over-screen" id="gameOverScreen">
        <h2 style="color: #fc0000; font-size: 20px;">GAME OVER</h2>
        <p style="margin: 20px 0;">FINAL SCORE: <span id="finalScore">0</span></p>
        <button class="pixel-btn" onclick="restartGame()">TRY AGAIN</button>
        <button class="pixel-btn" onclick="backToMenu()">MAIN MENU</button>
    </div>
    
    <!-- Game Canvas -->
    <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>

<script>
// ===== 8-BIT GAME ENGINE =====
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false; // Pixel-perfect rendering

// Game State
let gameRunning = false;
let score = 0;
let level = 1;
let lives = 3;
let secretKeysCollected = 0;

// Player
const player = {
    x: 100,
    y: 400,
    width: 32,
    height: 32,
    velX: 0,
    velY: 0,
    speed: 4,
    jumping: false,
    jumpPower: 12,
    gravity: 0.5,
    color: '#fcfc00',
    direction: 1 // 1 = right, -1 = left
};

// Input
const keys = {};
document.addEventListener('keydown', (e) => {
    keys[e.key] = true;
    if (e.key === 'ArrowUp' && !player.jumping) {
        player.velY = -player.jumpPower;
        player.jumping = true;
        playSound('jump');
    }
});
document.addEventListener('keyup', (e) => {
    keys[e.key] = false;
});

// Enemies
let enemies = [];
let powerUps = [];
let secretKeys = [];
let particles = [];

// Level Design
const platforms = [
    { x: 0, y: 550, width: 800, height: 50 }, // Ground
    { x: 200, y: 450, width: 150, height: 20 },
    { x: 400, y: 350, width: 150, height: 20 },
    { x: 100, y: 250, width: 100, height: 20 },
    { x: 600, y: 450, width: 150, height: 20 },
    { x: 500, y: 200, width: 200, height: 20 }
];

// Initialize Level
function initLevel() {
    enemies = [];
    powerUps = [];
    secretKeys = [];
    
    // Spawn enemies (bacteria)
    for (let i = 0; i < 3 + level; i++) {
        enemies.push({
            x: Math.random() * 700 + 50,
            y: 500,
            width: 24,
            height: 24,
            velX: (Math.random() - 0.5) * 2,
            color: '#fc0000',
            type: 'bacteria'
        });
    }
    
    // Spawn power-ups
    for (let i = 0; i < 2; i++) {
        powerUps.push({
            x: Math.random() * 700 + 50,
            y: Math.random() * 300 + 100,
            width: 20,
            height: 20,
            color: '#00fc00',
            type: 'health'
        });
    }
    
    // Secret key (random spawn)
    if (Math.random() < 0.5) {
        secretKeys.push({
            x: Math.random() * 600 + 100,
            y: 150,
            width: 20,
            height: 20,
            collected: false
        });
    }
}

// Start Game
function startGame() {
    document.getElementById('startScreen').style.display = 'none';
    gameRunning = true;
    score = 0;
    level = 1;
    lives = 3;
    secretKeysCollected = 0;
    player.x = 100;
    player.y = 400;
    initLevel();
    gameLoop();
}

// Restart Game
function restartGame() {
    document.getElementById('gameOverScreen').style.display = 'none';
    startGame();
}

// Back to Menu
function backToMenu() {
    document.getElementById('gameOverScreen').style.display = 'none';
    document.getElementById('startScreen').style.display = 'block';
    gameRunning = false;
}

// Game Loop
function gameLoop() {
    if (!gameRunning) return;
    
    update();
    render();
    
    requestAnimationFrame(gameLoop);
}

// Update
function update() {
    // Player movement
    if (keys['ArrowLeft']) {
        player.velX = -player.speed;
        player.direction = -1;
    } else if (keys['ArrowRight']) {
        player.velX = player.speed;
        player.direction = 1;
    } else {
        player.velX *= 0.8; // Friction
    }
    
    // Gravity
    player.velY += player.gravity;
    
    // Update position
    player.x += player.velX;
    player.y += player.velY;
    
    // Ground collision
    if (player.y + player.height > 550) {
        player.y = 550 - player.height;
        player.velY = 0;
        player.jumping = false;
    }
    
    // Platform collision
    platforms.forEach(platform => {
        if (player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y + player.height > platform.y &&
            player.y + player.height < platform.y + 20 &&
            player.velY > 0) {
            player.y = platform.y - player.height;
            player.velY = 0;
            player.jumping = false;
        }
    });
    
    // Screen bounds
    if (player.x < 0) player.x = 0;
    if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
    
    // Update enemies
    enemies.forEach((enemy, index) => {
        enemy.x += enemy.velX;
        
        // Bounce off walls
        if (enemy.x < 0 || enemy.x + enemy.width > canvas.width) {
            enemy.velX *= -1;
        }
        
        // Collision with player
        if (checkCollision(player, enemy)) {
            lives--;
            playSound('hit');
            createParticles(player.x, player.y, '#fc0000');
            
            if (lives <= 0) {
                gameOver();
            } else {
                // Respawn player
                player.x = 100;
                player.y = 400;
            }
        }
    });
    
    // Update power-ups
    powerUps.forEach((powerUp, index) => {
        if (checkCollision(player, powerUp)) {
            score += 100;
            playSound('coin');
            createParticles(powerUp.x, powerUp.y, '#00fc00');
            powerUps.splice(index, 1);
        }
    });
    
    // Update secret keys
    secretKeys.forEach((key, index) => {
        if (!key.collected && checkCollision(player, key)) {
            secretKeysCollected++;
            key.collected = true;
            score += 500;
            playSound('secret');
            createParticles(key.x, key.y, '#fcfc00');
            secretKeys.splice(index, 1);
        }
    });
    
    // Update particles
    particles = particles.filter(p => {
        p.x += p.velX;
        p.y += p.velY;
        p.life--;
        return p.life > 0;
    });
    
    // Level complete
    if (powerUps.length === 0 && enemies.length === 0) {
        level++;
        score += 1000;
        playSound('levelup');
        initLevel();
    }
    
    // Update HUD
    document.getElementById('scoreDisplay').textContent = score;
    document.getElementById('levelDisplay').textContent = level;
    document.getElementById('livesDisplay').textContent = lives;
}

// Render
function render() {
    // Clear screen
    ctx.fillStyle = '#5c94fc'; // Sky blue
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw clouds (8-bit style)
    drawClouds();
    
    // Draw platforms
    ctx.fillStyle = '#8b4513';
    platforms.forEach(platform => {
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        // Grass on top
        ctx.fillStyle = '#00fc00';
        ctx.fillRect(platform.x, platform.y - 4, platform.width, 4);
        ctx.fillStyle = '#8b4513';
    });
    
    // Draw player (pixelated tooth)
    drawPlayer();
    
    // Draw enemies (bacteria)
    enemies.forEach(enemy => {
        drawBacteria(enemy.x, enemy.y, enemy.width);
    });
    
    // Draw power-ups
    powerUps.forEach(powerUp => {
        drawPowerUp(powerUp.x, powerUp.y);
    });
    
    // Draw secret keys
    secretKeys.forEach(key => {
        if (!key.collected) {
            drawKey(key.x, key.y);
        }
    });
    
    // Draw particles
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 4, 4);
    });
}

// Draw Player (8-bit tooth)
function drawPlayer() {
    ctx.fillStyle = '#ffffff';
    // Body (tooth shape)
    ctx.fillRect(player.x + 8, player.y, 16, 24);
    ctx.fillRect(player.x + 4, player.y + 8, 24, 16);
    
    // Eyes
    ctx.fillStyle = '#000';
    if (player.direction === 1) {
        ctx.fillRect(player.x + 14, player.y + 8, 4, 4);
        ctx.fillRect(player.x + 20, player.y + 8, 4, 4);
    } else {
        ctx.fillRect(player.x + 8, player.y + 8, 4, 4);
        ctx.fillRect(player.x + 14, player.y + 8, 4, 4);
    }
    
    // Smile
    ctx.fillRect(player.x + 12, player.y + 16, 8, 2);
}

// Draw Bacteria (8-bit enemy)
function drawBacteria(x, y, size) {
    ctx.fillStyle = '#00fc00';
    // Body
    ctx.fillRect(x + 4, y + 4, size - 8, size - 8);
    ctx.fillRect(x + 8, y, size - 16, size);
    
    // Eyes
    ctx.fillStyle = '#fc0000';
    ctx.fillRect(x + 8, y + 6, 3, 3);
    ctx.fillRect(x + size - 11, y + 6, 3, 3);
}

// Draw Power-up (pill)
function drawPowerUp(x, y) {
    ctx.fillStyle = '#fc0000';
    ctx.fillRect(x, y + 4, 20, 12);
    ctx.fillStyle = '#fcfc00';
    ctx.fillRect(x + 10, y + 4, 10, 12);
}

// Draw Key
function drawKey(x, y) {
    ctx.fillStyle = '#fcfc00';
    ctx.fillRect(x + 4, y, 12, 8);
    ctx.fillRect(x, y + 8, 8, 4);
    ctx.fillRect(x, y + 14, 8, 4);
}

// Draw Clouds
function drawClouds() {
    ctx.fillStyle = '#ffffff';
    const time = Date.now() * 0.0001;
    for (let i = 0; i < 3; i++) {
        const x = ((time * 20 + i * 250) % 900) - 100;
        const y = 50 + i * 40;
        ctx.fillRect(x, y, 60, 20);
        ctx.fillRect(x + 15, y - 10, 30, 10);
    }
}

// Collision Detection
function checkCollision(obj1, obj2) {
    return obj1.x < obj2.x + obj2.width &&
           obj1.x + obj1.width > obj2.x &&
           obj1.y < obj2.y + obj2.height &&
           obj1.y + obj1.height > obj2.y;
}

// Create Particles
function createParticles(x, y, color) {
    for (let i = 0; i < 10; i++) {
        particles.push({
            x: x,
            y: y,
            velX: (Math.random() - 0.5) * 4,
            velY: (Math.random() - 0.5) * 4,
            color: color,
            life: 30
        });
    }
}

// Game Over
function gameOver() {
    gameRunning = false;
    document.getElementById('finalScore').textContent = score;
    document.getElementById('gameOverScreen').style.display = 'block';
    playSound('gameover');
}

// 8-bit Sound Effects
function playSound(type) {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    switch(type) {
        case 'jump':
            oscillator.frequency.value = 500;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
            break;
        case 'coin':
            oscillator.frequency.value = 800;
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
            break;
        case 'hit':
            oscillator.type = 'sawtooth';
            oscillator.frequency.value = 100;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
            break;
        case 'secret':
            oscillator.frequency.value = 1000;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            oscillator.start(audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1500, audioContext.currentTime + 0.3);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            oscillator.stop(audioContext.currentTime + 0.3);
            break;
        case 'levelup':
            oscillator.frequency.value = 600;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            oscillator.start(audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.5);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            oscillator.stop(audioContext.currentTime + 0.5);
            break;
        case 'gameover':
            oscillator.type = 'sawtooth';
            oscillator.frequency.value = 200;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            oscillator.start(audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.8);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
            oscillator.stop(audioContext.currentTime + 0.8);
            break;
    }
}
</script>
{% endblock %}

